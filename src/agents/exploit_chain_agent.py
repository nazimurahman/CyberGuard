"""
Exploit Chain Reasoning Agent
Purpose: Detects multi-step attack chains, privilege escalation attempts, and lateral movement
Techniques: Attack graph analysis, MITRE ATT&CK mapping, correlation analysis, sequence detection
"""

# Import necessary modules and libraries
from typing import Dict, List, Any, Set, Tuple, Optional, Deque  # Type hints for better code documentation and IDE support
from datetime import datetime, timedelta  # For handling dates and times
import networkx as nx  # NetworkX library for graph operations and analysis
import numpy as np  # NumPy for numerical computations and statistical operations
import time  # For time-related functions and performance measurement
from collections import defaultdict, deque  # Specialized data structures for efficient data handling

# Import base agent class and capabilities from local module
from .base_agent import SecurityAgent, AgentCapability  # Assuming base_agent.py exists in the same directory


# Define the main agent class that inherits from SecurityAgent
class ExploitChainReasoningAgent(SecurityAgent):
    """
    Exploit Chain Reasoning Agent
    
    This agent specializes in detecting:
    1. Multi-step attack chains - sequences of related attack steps
    2. Privilege escalation attempts - attempts to gain higher system privileges
    3. Lateral movement - moving between systems within a network
    4. Persistence mechanisms - techniques attackers use to maintain access
    5. Defense evasion techniques - methods to avoid detection
    6. Command and control (C2) communication - communication with attacker infrastructure
    7. Data exfiltration attempts - attempts to steal data
    8. Attack campaign correlation - grouping related attacks into campaigns
    
    Techniques used:
    - MITRE ATT&CK framework mapping - mapping events to known attack techniques
    - Attack graph analysis - using graph theory to model attack paths
    - Sequence pattern recognition - identifying patterns in event sequences
    - Temporal correlation - finding relationships based on timing
    - Behavioral chain analysis - analyzing sequences of behaviors
    - Threat intelligence correlation - correlating with known threat information
    - Graph database queries - querying graph structures for insights
    """
    
    # Constructor method - called when creating a new instance of the agent
    def __init__(self, agent_id: str = "exploit_chain_001"):
        """
        Initialize the Exploit Chain Reasoning Agent
        
        Args:
            agent_id: Unique identifier for the agent, defaults to "exploit_chain_001"
        """
        # Call parent class constructor with agent configuration
        super().__init__(
            agent_id=agent_id,  # Unique identifier for this agent instance
            name="Exploit Chain Reasoning Agent",  # Human-readable name for the agent
            state_dim=1024  # State dimension for the agent's reasoning capacity, large for complex analysis
        )
        
        # Add exploit chain detection capability to the agent's capabilities list
        # This enables the agent to perform chain detection operations
        self.capabilities.append(AgentCapability.EXPLOIT_CHAIN_DETECTION)
        
        # MITRE ATT&CK techniques database - loads known attack techniques
        # Maps technique IDs to detailed technique information including name, description, examples
        self.mitre_techniques = self._load_mitre_techniques()
        
        # Attack chain patterns - predefined sequences of MITRE techniques
        # These are known attack flows that the agent looks for during analysis
        self.attack_patterns = self._load_attack_patterns()
        
        # Attack graph for correlation - uses NetworkX directed graph structure
        # Graph nodes represent entities (sources, targets, techniques)
        # Graph edges represent relationships between entities
        self.attack_graph = nx.DiGraph()  # Directed graph for representing attack flows
        
        # Event sequences for detection - stores recent events per source IP
        # defaultdict creates a new deque when accessing a non-existent key
        # deque is used for efficient appending and popping from both ends
        self.event_sequences: Dict[str, Deque[Dict]] = defaultdict(lambda: deque(maxlen=self.max_sequence_length))
        self.max_sequence_length = 100  # Maximum number of events to keep per source IP for analysis
        
        # Time window for correlation in seconds - events within this window are considered related
        self.correlation_window = 3600  # 1 hour window for temporal correlation
        
        # Detection thresholds for various metrics - configurable values that control detection sensitivity
        self.thresholds = {
            'chain_confidence': 0.7,  # Minimum confidence score to consider a chain as valid detection
            'temporal_correlation': 0.8,  # Threshold for time-based correlation between events
            'behavioral_similarity': 0.6,  # Minimum similarity score for behavioral pattern matching
            'min_chain_length': 3,  # Minimum number of steps required for a valid attack chain
            'max_time_gap': 300,  # Maximum allowed time gap (5 minutes) between steps in a chain
        }
        
        # Campaign tracking - groups related attack chains into campaigns
        # Campaigns represent coordinated attack activities over time
        self.campaigns: Dict[str, Dict] = {}  # Dictionary mapping campaign IDs to campaign data
        self.campaign_counter = 0  # Counter for generating unique sequential campaign IDs
        
        # Metrics for monitoring agent performance and detection statistics
        # These metrics help evaluate the agent's effectiveness and track detection patterns
        self.metrics = {
            'events_processed': 0,  # Total number of security events processed by the agent
            'chains_detected': 0,  # Total number of attack chains detected
            'campaigns_identified': 0,  # Total number of campaigns identified
            'false_positives': 0,  # Number of false positive detections (currently not used)
            'avg_chain_length': 0.0,  # Average length of detected attack chains
            'graph_nodes': 0,  # Number of nodes in the attack graph
            'graph_edges': 0  # Number of edges in the attack graph
        }
    
    # Load MITRE ATT&CK techniques from internal database or external source
    def _load_mitre_techniques(self) -> Dict[str, Dict]:
        """
        Load MITRE ATT&CK techniques
        
        MITRE ATT&CK is a globally accessible knowledge base of adversary tactics and techniques
        Returns a dictionary mapping technique IDs to technique details including name, tactic, description
        
        Returns:
            Dictionary of MITRE ATT&CK techniques where keys are technique IDs and values are technique details
        """
        # In production implementation, this would load from MITRE ATT&CK JSON files
        # For demonstration purposes, a simplified static dictionary is used
        return {
            'T1190': {  # Technique ID for "Exploit Public-Facing Application"
                'id': 'T1190',  # Unique technique identifier
                'name': 'Exploit Public-Facing Application',  # Human-readable technique name
                'tactic': 'Initial Access',  # MITRE ATT&CK tactic category
                'description': 'Adversaries may attempt to exploit a weakness in an Internet-facing computer or program.',  # Detailed description
                'examples': ['Web shell upload', 'SQL injection', 'XSS to RCE']  # Common examples of this technique
            },
            'T1133': {  # Technique ID for "External Remote Services"
                'id': 'T1133',
                'name': 'External Remote Services',
                'tactic': 'Persistence',  # Technique belongs to Persistence tactic
                'description': 'Adversaries may use external remote services to maintain access to systems.',
                'examples': ['RDP', 'VPN', 'SSH']  # Examples include Remote Desktop Protocol, VPN, SSH
            },
            'T1059': {  # Technique ID for "Command and Scripting Interpreter"
                'id': 'T1059',
                'name': 'Command and Scripting Interpreter',
                'tactic': 'Execution',  # Technique belongs to Execution tactic
                'description': 'Adversaries may abuse command and script interpreters to execute commands.',
                'examples': ['PowerShell', 'Bash', 'Python']  # Common scripting interpreters
            },
            'T1068': {  # Technique ID for "Exploitation for Privilege Escalation"
                'id': 'T1068',
                'name': 'Exploitation for Privilege Escalation',
                'tactic': 'Privilege Escalation',  # Technique belongs to Privilege Escalation tactic
                'description': 'Adversaries may exploit software vulnerabilities to elevate privileges.',
                'examples': ['Local privilege escalation', 'Kernel exploits']  # Examples of privilege escalation
            },
            'T1021': {  # Technique ID for "Remote Services"
                'id': 'T1021',
                'name': 'Remote Services',
                'tactic': 'Lateral Movement',  # Technique belongs to Lateral Movement tactic
                'description': 'Adversaries may use remote services to move between systems.',
                'examples': ['SMB', 'RPC', 'WinRM']  # Common remote service protocols
            },
            'T1048': {  # Technique ID for "Exfiltration Over Alternative Protocol"
                'id': 'T1048',
                'name': 'Exfiltration Over Alternative Protocol',
                'tactic': 'Exfiltration',  # Technique belongs to Exfiltration tactic
                'description': 'Adversaries may steal data by exfiltrating it over a different protocol.',
                'examples': ['DNS tunneling', 'HTTP upload', 'ICMP']  # Alternative protocols for data theft
            },
            'T1070': {  # Technique ID for "Indicator Removal on Host"
                'id': 'T1070',
                'name': 'Indicator Removal on Host',
                'tactic': 'Defense Evasion',  # Technique belongs to Defense Evasion tactic
                'description': 'Adversaries may delete or modify generated artifacts to avoid detection.',
                'examples': ['Clear logs', 'Delete files', 'Timestomping']  # Examples of indicator removal
            }
        }
    
    # Load known attack chain patterns for pattern matching
    def _load_attack_patterns(self) -> Dict[str, List[List[str]]]:
        """
        Load known attack chain patterns
        
        Each pattern is a sequence of MITRE ATT&CK techniques representing a common attack flow
        Multiple sequences per pattern allow for variations in attack chains
        
        Returns:
            Dictionary mapping pattern names to lists of technique sequences
            Pattern names are human-readable identifiers for attack types
            Each technique sequence is a list of MITRE technique IDs in attack order
        """
        return {
            'web_shell_attack': [  # Pattern name for web shell-based attacks
                ['T1190', 'T1059', 'T1068', 'T1021', 'T1048'],  # Full web shell attack chain: Initial access -> Execution -> Privilege escalation -> Lateral movement -> Exfiltration
                ['T1190', 'T1059', 'T1133', 'T1048'],  # Alternative sequence: Initial access -> Execution -> Persistence -> Exfiltration
                ['T1190', 'T1059', 'T1070', 'T1048']   # Alternative sequence: Initial access -> Execution -> Defense evasion -> Exfiltration
            ],
            'ransomware_attack': [  # Pattern name for ransomware attacks
                ['T1133', 'T1059', 'T1021', 'T1070'],  # Ransomware via remote services: Persistence -> Execution -> Lateral movement -> Defense evasion
                ['T1190', 'T1059', 'T1021', 'T1070']   # Ransomware via web exploit: Initial access -> Execution -> Lateral movement -> Defense evasion
            ],
            'data_theft': [  # Pattern name for data theft attacks
                ['T1190', 'T1059', 'T1048'],  # Web-based data theft: Initial access -> Execution -> Exfiltration
                ['T1133', 'T1059', 'T1048'],  # Remote service data theft: Persistence -> Execution -> Exfiltration
                ['T1133', 'T1021', 'T1048']   # Lateral movement then data theft: Persistence -> Lateral movement -> Exfiltration
            ],
            'lateral_movement': [  # Pattern name for lateral movement-focused attacks
                ['T1190', 'T1059', 'T1021', 'T1021', 'T1021'],  # Multiple lateral movements: Initial access -> Execution -> Repeated lateral movements
                ['T1133', 'T1021', 'T1021', 'T1068']  # Lateral with privilege escalation: Persistence -> Lateral movements -> Privilege escalation
            ]
        }
    
    # Main analysis method - entry point for security event analysis
    def analyze(self, security_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Analyze security events for exploit chains
        
        Process flow:
        1. Extract and classify events from input security data
        2. Map events to MITRE ATT&CK techniques
        3. Add events to attack graph for correlation analysis
        4. Correlate events with existing sequences for temporal analysis
        5. Detect attack chains using pattern matching and sequence analysis
        6. Identify campaigns by grouping related attack chains
        7. Predict next possible attack steps based on detected chains
        
        Args:
            security_data: Dictionary containing security events or analyses from other agents
            Typically includes events, alerts, logs, or analysis results
            
        Returns:
            Dictionary with comprehensive analysis results including detected chains,
            identified campaigns, predictions, and recommended actions
        """
        # Record start time for performance measurement
        start_time = time.time()
        
        # Use try-except block for error handling during analysis
        try:
            # Extract events from the input security data
            # This converts raw security data into standardized event format
            events = self._extract_events(security_data)
            
            # Check if any events were extracted
            # If no events, return minimal response to avoid unnecessary processing
            if not events:
                return {
                    'agent_id': self.agent_id,  # Identifier of this agent instance
                    'agent_name': self.name,  # Human-readable name of the agent
                    'chains_detected': [],  # Empty list since no chains detected
                    'campaigns': [],  # Empty list since no campaigns identified
                    'prediction': None  # No predictions without events
                }
            
            # Update metrics to track processing volume
            self.metrics['events_processed'] += len(events)
            
            # Initialize lists to accumulate detection results
            all_chains = []  # Will contain all detected attack chains
            all_campaigns = []  # Will contain all identified campaign IDs
            
            # Process each event individually
            # This loop performs the core analysis on each security event
            for event in events:
                # Map event to MITRE ATT&CK technique using keyword analysis
                # Returns technique dictionary if mapping successful, None otherwise
                technique = self._map_to_mitre(event)
                
                # Only process events that can be mapped to MITRE techniques
                if technique:
                    # Add event to attack graph for structural correlation
                    # Builds relationships between sources, techniques, and targets
                    self._add_to_attack_graph(event, technique)
                    
                    # Add event to temporal sequences for sequence analysis
                    # Maintains time-ordered sequences of events per source
                    self._add_to_sequences(event, technique)
                    
                    # Detect attack chains involving this event
                    # Looks for patterns in event sequences that match known attack flows
                    chains = self._detect_chains(event, technique)
                    all_chains.extend(chains)  # Add detected chains to accumulator
                    
                    # Update campaigns with this event and detected chains
                    # Groups related events and chains into campaigns for broader context
                    campaigns = self._update_campaigns(event, technique, chains)
                    all_campaigns.extend(campaigns)  # Add campaign IDs to accumulator
            
            # Update graph metrics after processing all events
            # These metrics help monitor the growth and complexity of the attack graph
            self.metrics['graph_nodes'] = len(self.attack_graph.nodes())
            self.metrics['graph_edges'] = len(self.attack_graph.edges())
            
            # Predict next possible attack steps based on detected chains
            # Uses pattern progression and historical data to forecast future attacks
            predictions = self._predict_next_steps(all_chains)
            
            # Calculate total processing time for performance monitoring
            processing_time = time.time() - start_time
            
            # Generate comprehensive response dictionary with analysis results
            response = {
                'agent_id': self.agent_id,  # Identifier of this agent
                'agent_name': self.name,  # Human-readable name
                'analysis_timestamp': datetime.now().isoformat(),  # When analysis was performed
                'processing_time': processing_time,  # How long analysis took in seconds
                'events_processed': len(events),  # Number of events analyzed
                'chains_detected': all_chains[:10],  # Detected chains, limited to first 10 for response size
                'campaigns_identified': list(set(all_campaigns)),  # Unique campaign IDs identified
                'predictions': predictions,  # Predicted next attack steps
                'attack_graph_summary': {  # Statistics about the attack graph
                    'nodes': self.metrics['graph_nodes'],  # Number of nodes in graph
                    'edges': self.metrics['graph_edges'],  # Number of edges in graph
                    'density': nx.density(self.attack_graph) if self.attack_graph.number_of_nodes() > 0 else 0  # Graph density measure
                },
                'recommended_action': self._get_recommended_action(all_chains, predictions),  # Action recommendation based on analysis
                'reasoning_state': self.get_reasoning_state(),  # Current reasoning state from parent class
                'decision': {  # Decision information for automated response systems
                    'threat_level': self._compute_chain_threat(all_chains),  # Calculated threat level (0-1)
                    'confidence': self._compute_chain_confidence(all_chains),  # Confidence in detection (0-1)
                    'evidence': all_chains[:3] if all_chains else []  # Top 3 chains as supporting evidence
                }
            }
            
            # Update agent confidence based on detection results
            # More detected chains increase agent confidence in its analysis
            if all_chains:
                # Calculate certainty as minimum of 0.9 or 0.1 per chain
                certainty = min(0.9, len(all_chains) * 0.1)
                # Update confidence in parent class
                self.update_confidence({'certainty': certainty})
            
            # Return the complete analysis response
            return response
            
        # Handle any exceptions that occur during analysis
        except Exception as e:
            # Print error message for debugging and monitoring
            print(f"Exploit chain analysis error: {e}")
            # Return error response to indicate analysis failure
            return self._error_response(str(e))
    
    # Extract events from various types of security data
    def _extract_events(self, security_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Extract security events from data
        
        Events can come from multiple sources:
        - Log files from systems and applications
        - IDS/IPS alerts from intrusion detection/prevention systems
        - Endpoint detection from host-based security agents
        - Network monitoring from network traffic analysis
        - Application logs from web servers, databases, etc.
        
        Args:
            security_data: Dictionary containing security data in various formats
            
        Returns:
            List of extracted and validated events in standardized format
        """
        # Initialize empty list to collect events
        events = []
        
        # Check for direct events in the security data
        # Some data sources provide events in a standardized list format
        if 'events' in security_data:
            # Verify that events is a list before extending
            if isinstance(security_data['events'], list):
                # Add all events from the events list
                events.extend(security_data['events'])
        
        # Extract events from agent analyses
        # Other security agents may provide analysis results that contain findings
        for key, value in security_data.items():
            # Look for keys ending with '_analysis' indicating agent analysis results
            if key.endswith('_analysis'):
                # Check if value is a dictionary and contains findings
                if isinstance(value, dict) and 'findings' in value:
                    # Convert analysis to standardized event format
                    event = self._create_event_from_analysis(value, key)
                    # Add to events list
                    events.append(event)
        
        # Filter events to ensure they have required fields and valid format
        valid_events = []
        for event in events:
            # Validate each event before including in analysis
            if self._is_valid_event(event):
                valid_events.append(event)
        
        # Return only valid events for further processing
        return valid_events
    
    # Create standardized event from agent analysis results
    def _create_event_from_analysis(self, analysis: Dict[str, Any], source: str) -> Dict[str, Any]:
        """
        Create standardized event from agent analysis
        
        Converts analysis results from other agents into a consistent event format
        that can be processed by the exploit chain reasoning agent
        
        Args:
            analysis: Dictionary containing analysis results from another agent
            source: Source identifier indicating which agent provided the analysis
            
        Returns:
            Standardized event dictionary with consistent field names and types
        """
        # Create basic event structure with default values
        event = {
            'timestamp': analysis.get('analysis_timestamp', datetime.now().isoformat()),  # When analysis was performed
            'source': source,  # Which agent provided this analysis
            'source_ip': analysis.get('ip_address', 'unknown'),  # Source IP address if available
            'destination_ip': analysis.get('target_ip', 'unknown'),  # Destination IP address if available
            'event_type': analysis.get('type', 'security_alert'),  # Type of security event
            'severity': analysis.get('severity', 'medium'),  # Severity level (low, medium, high, critical)
            'description': analysis.get('description', 'Security event detected'),  # Human-readable description
            'raw_data': analysis  # Keep original analysis data for reference
        }
        
        # Extract MITRE technique indicators from detections if present
        # Some agents may provide technique hints in their detections
        if 'detections' in analysis:
            # Get detections list from analysis
            detections = analysis['detections']
            # Ensure detections is a list before processing
            if isinstance(detections, list):
                # Process each detection in the list
                for detection in detections:
                    # Ensure detection is a dictionary and has type information
                    if isinstance(detection, dict) and 'type' in detection:
                        # Initialize technique_hints list if not present
                        event['technique_hints'] = event.get('technique_hints', [])
                        # Add detection type as technique hint
                        event['technique_hints'].append(detection['type'])
        
        # Return the standardized event
        return event
    
    # Validate event structure and content
    def _is_valid_event(self, event: Dict[str, Any]) -> bool:
        """
        Validate event has required fields and proper format
        
        Ensures events have all necessary fields for analysis
        Validates timestamp format to prevent processing errors
        
        Args:
            event: Event dictionary to validate
            
        Returns:
            Boolean indicating if event is valid for processing
            True if event has all required fields and valid timestamp
            False otherwise
        """
        # Define required fields that every event must have
        required = ['timestamp', 'event_type', 'description']
        
        # Check for required fields
        for field in required:
            if field not in event:
                # Event missing required field, invalid
                return False
        
        # Validate timestamp format
        try:
            # Handle ISO format with or without timezone
            timestamp_str = event['timestamp']
            # Convert 'Z' suffix to '+00:00' for ISO format compatibility
            if timestamp_str.endswith('Z'):
                timestamp_str = timestamp_str[:-1] + '+00:00'
            # Attempt to parse timestamp to validate format
            datetime.fromisoformat(timestamp_str)
        except (ValueError, TypeError, AttributeError):
            # Timestamp parsing failed, event invalid
            return False
        
        # All validation passed, event is valid
        return True
    
    # Map security event to MITRE ATT&CK technique
    def _map_to_mitre(self, event: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        Map event to MITRE ATT&CK technique
        
        Uses pattern matching and keyword analysis to identify
        which MITRE technique best describes the security event
        
        Args:
            event: Security event to map to MITRE technique
            
        Returns:
            MITRE technique dictionary if mapping successful
            None if no technique matches the event
        """
        # Convert description and event_type to lowercase for case-insensitive matching
        description = str(event.get('description', '')).lower()
        event_type = str(event.get('event_type', '')).lower()
        
        # Get technique hints from event if available
        # These are pre-identified technique indicators from other agents
        technique_hints = event.get('technique_hints', [])
        # Convert hints to lowercase strings for consistent matching
        hint_strings = [str(hint).lower() for hint in technique_hints if hint]
        
        # Define mapping rules as tuples of (keywords, technique_id)
        # Each rule specifies keywords that indicate a particular MITRE technique
        mapping_rules = [
            # Initial Access techniques
            (['web shell', 'php shell', 'backdoor'], 'T1190'),  # Web shells indicate T1190
            (['sql injection', 'sqli'], 'T1190'),  # SQL injection indicates T1190
            (['xss', 'cross-site scripting'], 'T1190'),  # XSS indicates T1190
            (['brute force', 'password spray'], 'T1110'),  # Brute force indicates T1110
            
            # Execution techniques
            (['command execution', 'cmd.exe', 'powershell'], 'T1059'),  # Command execution indicates T1059
            (['python', 'perl', 'ruby script'], 'T1059'),  # Script execution indicates T1059
            (['bash', 'shell script'], 'T1059'),  # Shell scripts indicate T1059
            
            # Persistence techniques
            (['scheduled task', 'cron job', 'startup'], 'T1053'),  # Scheduled tasks indicate T1053
            (['service installation', 'daemon'], 'T1543'),  # Service installation indicates T1543
            (['registry', 'run key'], 'T1547'),  # Registry modifications indicate T1547
            
            # Privilege Escalation techniques
            (['privilege escalation', 'sudo', 'runas'], 'T1068'),  # Privilege escalation indicates T1068
            (['kernel exploit', 'local exploit'], 'T1068'),  # Local exploits indicate T1068
            
            # Lateral Movement techniques
            (['lateral movement', 'psexec', 'wmic'], 'T1021'),  # Lateral movement tools indicate T1021
            (['rdp', 'remote desktop'], 'T1021'),  # RDP indicates T1021
            (['ssh', 'secure shell'], 'T1021'),  # SSH indicates T1021
            
            # Exfiltration techniques
            (['data exfiltration', 'data theft'], 'T1048'),  # Data exfiltration indicates T1048
            (['dns tunneling', 'dns exfiltration'], 'T1048'),  # DNS tunneling indicates T1048
            (['http upload', 'ftp transfer'], 'T1048'),  # File transfer indicates T1048
            
            # Defense Evasion techniques
            (['log clearing', 'event log'], 'T1070'),  # Log clearing indicates T1070
            (['file deletion', 'evidence removal'], 'T1070'),  # File deletion indicates T1070
            (['timestomping', 'timestamp modification'], 'T1070')  # Timestamp modification indicates T1070
        ]
        
        # Check each mapping rule against the event
        for keywords, technique_id in mapping_rules:
            # Check each keyword in the rule
            for keyword in keywords:
                # Check if keyword appears in description, event type, or technique hints
                if (keyword in description or 
                    keyword in event_type or
                    any(keyword in hint for hint in hint_strings)):
                    
                    # Verify technique exists in loaded MITRE techniques
                    if technique_id in self.mitre_techniques:
                        # Create copy of technique dictionary to avoid modifying original
                        technique = self.mitre_techniques[technique_id].copy()
                        # Add confidence score to technique
                        technique['confidence'] = 0.7
                        # Record which keyword triggered the match
                        technique['matched_keyword'] = keyword
                        # Return matched technique
                        return technique
        
        # If no specific match found, try generic mapping for malware events
        if 'malware' in description or 'virus' in description:
            # Return generic malware technique
            return {
                'id': 'T1203',  # Generic malware technique ID
                'name': 'Exploitation for Client Execution',  # Technique name
                'tactic': 'Execution',  # Tactic category
                'confidence': 0.5,  # Lower confidence for generic mapping
                'matched_keyword': 'malware'  # Keyword that triggered match
            }
        
        # No technique matched, return None
        return None
    
    # Add event to attack graph for structural correlation
    def _add_to_attack_graph(self, event: Dict[str, Any], technique: Dict[str, Any]) -> None:
        """
        Add event to attack graph for correlation
        
        The attack graph connects different entities to model attack relationships:
        - Sources and destinations (IP addresses, hosts)
        - Techniques and tactics (MITRE ATT&CK techniques)
        - Timelines and sequences (temporal relationships)
        
        Args:
            event: Security event with source, destination, and timestamp
            technique: MITRE technique dictionary with ID and details
        """
        # Extract source and destination IPs from event
        source_ip = event.get('source_ip', 'unknown')
        dest_ip = event.get('destination_ip', 'unknown')
        
        # Create unique node identifiers using prefixes
        source_node = f"src:{source_ip}"  # Source node with 'src:' prefix
        dest_node = f"dst:{dest_ip}"  # Destination node with 'dst:' prefix
        technique_node = f"tech:{technique['id']}"  # Technique node with 'tech:' prefix
        
        # Add source node to graph with attributes
        self.attack_graph.add_node(source_node, type='source', ip=source_ip)
        # Add destination node to graph with attributes
        self.attack_graph.add_node(dest_node, type='destination', ip=dest_ip)
        # Add technique node to graph with all technique attributes
        self.attack_graph.add_node(technique_node, type='technique', **technique)
        
        # Add edge from source to technique representing "source performed technique"
        self.attack_graph.add_edge(
            source_node, technique_node,  # Edge from source to technique
            timestamp=event['timestamp'],  # When this relationship occurred
            event_type=event['event_type'],  # Type of security event
            severity=event.get('severity', 'medium')  # Severity of the event
        )
        
        # Add edge from technique to destination representing "technique targeted destination"
        self.attack_graph.add_edge(
            technique_node, dest_node,  # Edge from technique to destination
            timestamp=event['timestamp'],  # When this relationship occurred
            event_type=event['event_type'],  # Type of security event
            severity=event.get('severity', 'medium')  # Severity of the event
        )
    
    # Add event to temporal sequences for sequence analysis
    def _add_to_sequences(self, event: Dict[str, Any], technique: Dict[str, Any]) -> None:
        """
        Add event to temporal sequences for chain detection
        
        Maintains time-ordered sequences of events per source IP
        These sequences are used to detect attack chains over time
        
        Args:
            event: Security event with timestamp and details
            technique: MITRE technique dictionary with ID and name
        """
        # Get source IP from event
        source_ip = event.get('source_ip', 'unknown')
        
        # Ensure deque exists for this source IP
        # If not, create a new deque with maximum length
        if source_ip not in self.event_sequences:
            self.event_sequences[source_ip] = deque(maxlen=self.max_sequence_length)
        
        # Create standardized sequence entry from event and technique
        sequence_entry = {
            'timestamp': event['timestamp'],  # Event timestamp
            'technique': technique['id'],  # MITRE technique ID
            'technique_name': technique['name'],  # MITRE technique name
            'event_type': event['event_type'],  # Type of security event
            'description': event['description'],  # Event description
            'severity': event.get('severity', 'medium')  # Event severity
        }
        
        # Add entry to the deque for this source IP
        # Deque automatically maintains maximum length
        self.event_sequences[source_ip].append(sequence_entry)
    
    # Detect attack chains involving a specific event
    def _detect_chains(self, event: Dict[str, Any], technique: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Detect attack chains involving this event
        
        Looks for patterns of techniques over time in event sequences
        Compares sequences against known attack patterns and detects emerging patterns
        
        Args:
            event: Security event that triggered chain detection
            technique: MITRE technique associated with the event
            
        Returns:
            List of detected attack chains with details and confidence scores
        """
        # Initialize empty list for detected chains
        chains = []
        # Get source IP from event
        source_ip = event.get('source_ip', 'unknown')
        
        # Check if there are sequences for this source IP
        # If no sequences, return empty list (no chains to detect)
        if source_ip not in self.event_sequences:
            return chains
        
        # Convert deque to list for easier indexing and slicing
        sequence = list(self.event_sequences[source_ip])
        
        # Check against known attack patterns from loaded patterns
        for pattern_name, pattern_sequences in self.attack_patterns.items():
            # Each pattern can have multiple sequence variations
            for pattern_sequence in pattern_sequences:
                # Try to match the current sequence against this pattern
                chain = self._match_pattern(sequence, pattern_sequence, pattern_name)
                # If match found, add to detected chains
                if chain:
                    chains.append(chain)
        
        # Detect emerging chains not in known patterns
        # Uses sequence mining to find new attack patterns
        emerging_chains = self._detect_emerging_chains(sequence)
        # Add emerging chains to detected chains
        chains.extend(emerging_chains)
        
        # Update detection metrics if chains were found
        if chains:
            # Increment total chains detected counter
            self.metrics['chains_detected'] += len(chains)
            # Extract lengths of all detected chains
            chain_lengths = [chain['length'] for chain in chains]
            # Calculate average chain length
            self.metrics['avg_chain_length'] = np.mean(chain_lengths) if chain_lengths else 0.0
        
        # Return all detected chains
        return chains
    
    # Match event sequence against known attack pattern
    def _match_pattern(self, sequence: List[Dict[str, Any]], pattern: List[str], pattern_name: str) -> Optional[Dict[str, Any]]:
        """
        Match sequence against attack pattern
        
        Uses sequence alignment with time constraints to find
        pattern occurrences in event sequences
        
        Args:
            sequence: List of events in chronological order
            pattern: List of MITRE technique IDs representing an attack pattern
            pattern_name: Name of the attack pattern for identification
            
        Returns:
            Matched chain dictionary with details if pattern found
            None if no match found
        """
        # Check if sequence is long enough to contain the pattern
        if len(sequence) < len(pattern):
            return None
        
        # Extract technique IDs from sequence events
        sequence_techniques = [event['technique'] for event in sequence]
        
        # Use sliding window to find pattern in sequence
        # Window slides through sequence one position at a time
        for i in range(len(sequence_techniques) - len(pattern) + 1):
            # Extract window of same length as pattern
            window = sequence_techniques[i:i + len(pattern)]
            
            # Check if window matches pattern
            if self._sequences_match(window, pattern):
                # Get corresponding events for this window
                window_events = sequence[i:i + len(pattern)]
                
                # Check if events in window meet time constraints
                if self._check_time_constraints(window_events):
                    # Calculate confidence score for this match
                    confidence = self._calculate_chain_confidence(window_events, pattern)
                    
                    # Check if confidence meets threshold
                    if confidence > self.thresholds['chain_confidence']:
                        # Return chain dictionary with all details
                        return {
                            'pattern_name': pattern_name,  # Name of matched pattern
                            'techniques': pattern,  # Pattern technique sequence
                            'events': window_events,  # Matching events from sequence
                            'confidence': confidence,  # Calculated confidence score
                            'start_time': window_events[0]['timestamp'],  # Start timestamp
                            'end_time': window_events[-1]['timestamp'],  # End timestamp
                            'length': len(pattern)  # Length of chain (number of steps)
                        }
        
        # No match found
        return None
    
    # Check if technique sequence window matches pattern
    def _sequences_match(self, window: List[str], pattern: List[str]) -> bool:
        """
        Check if window matches pattern
        
        Allows for some flexibility in matching to handle
        variations in attack sequences
        
        Args:
            window: List of technique IDs from sequence window
            pattern: List of technique IDs from attack pattern
            
        Returns:
            Boolean indicating if sequences match according to criteria
            True if sequences match, False otherwise
        """
        # First check if window and pattern have same length
        if len(window) != len(pattern):
            return False
        
        # Count exact matches between window and pattern
        matches = 0
        for w, p in zip(window, pattern):
            if w == p:
                matches += 1
        
        # Calculate match ratio (matches / total techniques)
        match_ratio = matches / len(pattern)
        # Require at least 70% match for flexibility
        # This allows for some variation in attack sequences
        return match_ratio >= 0.7
    
    # Check if events meet time constraints for chain validity
    def _check_time_constraints(self, events: List[Dict[str, Any]]) -> bool:
        """
        Check if events meet time constraints for a chain
        
        Events in a chain should be close in time to indicate
        coordinated activity rather than unrelated events
        
        Args:
            events: List of events to check for time constraints
            
        Returns:
            Boolean indicating if time constraints are met
            True if all time gaps are within threshold, False otherwise
        """
        # Single event or empty list automatically passes time constraints
        if len(events) < 2:
            return True
        
        # Convert timestamps to datetime objects for time calculations
        timestamps = []
        for event in events:
            try:
                # Get timestamp string from event
                timestamp_str = event['timestamp']
                # Handle ISO format with 'Z' timezone
                if timestamp_str.endswith('Z'):
                    timestamp_str = timestamp_str[:-1] + '+00:00'
                # Parse timestamp to datetime object
                dt = datetime.fromisoformat(timestamp_str)
                # Convert to Unix timestamp (seconds since epoch)
                timestamps.append(dt.timestamp())
            except (ValueError, TypeError, AttributeError):
                # If timestamp parsing fails, use current time as fallback
                timestamps.append(time.time())
        
        # Check time gaps between consecutive events
        for i in range(1, len(timestamps)):
            # Calculate time gap between event i and event i-1
            time_gap = timestamps[i] - timestamps[i-1]
            # Check if gap exceeds maximum allowed time gap
            if time_gap > self.thresholds['max_time_gap']:
                # Time gap too large, chain invalid
                return False
        
        # All time gaps within threshold, chain valid
        return True
    
    # Calculate confidence score for detected chain
    def _calculate_chain_confidence(self, events: List[Dict[str, Any]], pattern: List[str]) -> float:
        """
        Calculate confidence score for detected chain
        
        Confidence is calculated based on multiple factors:
        1. Technique match accuracy
        2. Time proximity of events
        3. Severity of events
        
        Args:
            events: List of events in the detected chain
            pattern: Pattern that was matched against
            
        Returns:
            Confidence score between 0 and 1
            0 = no confidence, 1 = maximum confidence
        """
        # Handle empty event list (shouldn't happen but defensive programming)
        if not events:
            return 0.0
        
        # Initialize list to collect confidence factors
        confidence_factors = []
        
        # 1. Technique match factor
        # Count how many events exactly match the pattern
        technique_matches = sum(1 for e, p in zip(events, pattern) if e['technique'] == p)
        # Calculate match ratio (matches / total techniques)
        technique_factor = technique_matches / len(pattern)
        confidence_factors.append(technique_factor)
        
        # 2. Time proximity factor
        # Convert event timestamps for time analysis
        timestamps = []
        for event in events:
            try:
                timestamp_str = event['timestamp']
                # Handle timezone format
                if timestamp_str.endswith('Z'):
                    timestamp_str = timestamp_str[:-1] + '+00:00'
                # Parse timestamp
                dt = datetime.fromisoformat(timestamp_str)
                # Get Unix timestamp
                timestamps.append(dt.timestamp())
            except:
                # Fallback to current time if parsing fails
                timestamps.append(time.time())
        
        # Calculate time factor if multiple events
        if len(timestamps) > 1:
            # Calculate total time span of chain
            total_time = timestamps[-1] - timestamps[0]
            # Calculate expected maximum time based on threshold and event count
            expected_max_time = self.thresholds['max_time_gap'] * len(events)
            # Time factor is inverse of time ratio (shorter chains get higher scores)
            time_factor = 1.0 - min(1.0, total_time / expected_max_time)
            confidence_factors.append(time_factor)
        
        # 3. Severity factor
        # Define numerical values for severity levels
        severities = {'low': 0.3, 'medium': 0.6, 'high': 0.9, 'critical': 1.0}
        # Extract severity values for each event
        severity_values = []
        for e in events:
            # Get severity with default 'medium'
            severity = e.get('severity', 'medium')
            # Convert to lowercase and get numerical value, default 0.5 if unknown
            severity_values.append(severities.get(severity.lower(), 0.5))
        
        # Calculate average severity
        avg_severity = np.mean(severity_values) if severity_values else 0.5
        confidence_factors.append(avg_severity)
        
        # Return average of all confidence factors
        return float(np.mean(confidence_factors))
    
    # Detect emerging chains not in predefined patterns
    def _detect_emerging_chains(self, sequence: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Detect emerging chains not in known patterns
        
        Uses sequence mining and behavioral analysis to identify
        new attack patterns that aren't in predefined patterns
        
        Args:
            sequence: List of events to analyze for emerging patterns
            
        Returns:
            List of detected emerging chains with details
        """
        # Initialize empty list for emerging chains
        chains = []
        
        # Check if sequence is long enough for chain detection
        if len(sequence) < self.thresholds['min_chain_length']:
            return chains
        
        # Look for repeating patterns of different lengths
        # Limit maximum chain length to 6 steps for practicality
        max_chain_length = min(6, len(sequence))
        # Try different chain lengths from minimum to maximum
        for chain_length in range(self.thresholds['min_chain_length'], max_chain_length + 1):
            # Slide window through sequence
            for i in range(len(sequence) - chain_length + 1):
                # Extract window of current chain length
                window = sequence[i:i + chain_length]
                
                # Check if this window forms a meaningful chain
                if self._is_meaningful_chain(window):
                    # Calculate confidence for this emerging chain
                    confidence = self._calculate_emerging_chain_confidence(window)
                    
                    # Check if confidence meets threshold
                    if confidence > self.thresholds['chain_confidence']:
                        # Add emerging chain to results
                        chains.append({
                            'pattern_name': 'emerging_chain',  # Special name for emerging patterns
                            'techniques': [e['technique'] for e in window],  # Techniques in chain
                            'events': window,  # Events in chain
                            'confidence': confidence,  # Calculated confidence
                            'start_time': window[0]['timestamp'],  # Start time
                            'end_time': window[-1]['timestamp'],  # End time
                            'length': chain_length  # Length of chain
                        })
        
        # Return all detected emerging chains
        return chains
    
    # Check if events form a meaningful attack chain
    def _is_meaningful_chain(self, events: List[Dict[str, Any]]) -> bool:
        """
        Check if events form a meaningful attack chain
        
        Criteria for meaningful chain:
        1. Multiple different techniques (not just repetition)
        2. Logical progression (e.g., access  execution  persistence)
        3. Not just repeated same event
        
        Args:
            events: List of events to check for meaningfulness
            
        Returns:
            Boolean indicating if events form a meaningful chain
            True if meaningful, False otherwise
        """
        # Chains must have at least 2 events
        if len(events) < 2:
            return False
        
        # Check for different techniques (not just repetition)
        # Extract unique technique IDs
        techniques = set(event['technique'] for event in events)
        # Need at least 2 different techniques for meaningful chain
        if len(techniques) < 2:
            return False
        
        # Check time constraints
        if not self._check_time_constraints(events):
            return False
        
        # Note: In production, add more sophisticated logic:
        # - MITRE tactic progression validation
        # - Behavioral consistency analysis
        # - Contextual relevance checking
        
        # Basic checks passed, chain is potentially meaningful
        return True
    
    # Calculate confidence for emerging chain
    def _calculate_emerging_chain_confidence(self, events: List[Dict[str, Any]]) -> float:
        """
        Calculate confidence for emerging chain
        
        Uses same calculation as regular chains but with
        the pattern derived from the events themselves
        
        Args:
            events: List of events in the emerging chain
            
        Returns:
            Confidence score between 0 and 1
        """
        # Create pattern from events' technique IDs
        pattern = [e['technique'] for e in events]
        # Use same confidence calculation as regular chains
        return self._calculate_chain_confidence(events, pattern)
    
    # Update campaigns with new event and chains
    def _update_campaigns(self, event: Dict[str, Any], technique: Dict[str, Any], chains: List[Dict[str, Any]]) -> List[str]:
        """
        Update campaigns with new event and chains
        
        Campaigns group related attacks by common attributes:
        - Source IP addresses
        - Techniques used
        - Timeframe of activity
        - Targets affected
        
        Args:
            event: Security event to add to campaigns
            technique: MITRE technique of the event
            chains: Detected chains involving this event
            
        Returns:
            List of campaign IDs this event belongs to
            Empty list if event doesn't belong to any campaign
        """
        # Initialize list to collect campaign IDs
        campaign_ids = []
        # Get source IP from event
        source_ip = event.get('source_ip', 'unknown')
        
        # Check existing campaigns for match
        for campaign_id, campaign in self.campaigns.items():
            # Check if event belongs to this campaign
            if self._event_belongs_to_campaign(event, technique, campaign):
                # Update campaign with this event
                self._update_campaign(campaign_id, event, technique, chains)
                # Add campaign ID to list
                campaign_ids.append(campaign_id)
        
        # Create new campaign if no match found and we have chains
        if not campaign_ids and chains:
            # Generate unique campaign ID with sequential counter
            new_campaign_id = f"campaign_{self.campaign_counter:04d}"
            # Increment campaign counter for next campaign
            self.campaign_counter += 1
            
            # Initialize new campaign structure
            self.campaigns[new_campaign_id] = {
                'id': new_campaign_id,  # Unique campaign identifier
                'start_time': event['timestamp'],  # When campaign started
                'last_seen': event['timestamp'],  # Most recent activity
                'source_ips': {source_ip},  # Set of source IPs (use set for uniqueness)
                'techniques': {technique['id']},  # Set of techniques used
                'chains': chains[:5],  # First 5 chains (limit for memory)
                'event_count': 1,  # Number of events in campaign
                'targets': {event.get('destination_ip', 'unknown')}  # Set of targets
            }
            
            # Update campaign metrics
            self.metrics['campaigns_identified'] += 1
            # Add new campaign ID to return list
            campaign_ids.append(new_campaign_id)
        
        # Return list of campaign IDs this event belongs to
        return campaign_ids
    
    # Check if event belongs to existing campaign
    def _event_belongs_to_campaign(self, event: Dict[str, Any], technique: Dict[str, Any], campaign: Dict[str, Any]) -> bool:
        """
        Check if event belongs to existing campaign
        
        Criteria for campaign membership:
        1. Same source IP or related IPs
        2. Similar techniques used
        3. Within time window of campaign activity
        
        Args:
            event: Security event to check
            technique: MITRE technique of the event
            campaign: Campaign to check against
            
        Returns:
            Boolean indicating if event belongs to campaign
            True if belongs, False otherwise
        """
        # Get source IP from event
        source_ip = event.get('source_ip', 'unknown')
        
        # Parse timestamps for time comparison
        try:
            # Parse event timestamp
            event_time_str = event['timestamp']
            if event_time_str.endswith('Z'):
                event_time_str = event_time_str[:-1] + '+00:00'
            event_time = datetime.fromisoformat(event_time_str)
            
            # Parse campaign's last seen timestamp
            last_seen_str = campaign['last_seen']
            if last_seen_str.endswith('Z'):
                last_seen_str = last_seen_str[:-1] + '+00:00'
            last_seen = datetime.fromisoformat(last_seen_str)
            
            # Check time window (within correlation window)
            time_diff = (event_time - last_seen).total_seconds()
            if time_diff > self.correlation_window:
                # Too much time passed, not same campaign
                return False
        except (ValueError, TypeError, KeyError):
            # If timestamp parsing fails, don't add to campaign
            return False
        
        # Check source IP match
        if source_ip in campaign['source_ips']:
            return True
        
        # Check technique similarity
        if technique['id'] in campaign['techniques']:
            return True
        
        # Note: In production, add more sophisticated IP correlation:
        # - Same subnet analysis
        # - Same ASN (Autonomous System Number)
        # - Geolocation proximity
        # - Known threat actor attribution
        
        # No match found
        return False
    
    # Update existing campaign with new event
    def _update_campaign(self, campaign_id: str, event: Dict[str, Any], technique: Dict[str, Any], chains: List[Dict[str, Any]]) -> None:
        """
        Update existing campaign with new event
        
        Adds event information to campaign and updates
        campaign statistics and timelines
        
        Args:
            campaign_id: Campaign identifier to update
            event: Security event to add to campaign
            technique: MITRE technique of the event
            chains: Detected chains involving this event
        """
        # Get campaign dictionary
        campaign = self.campaigns[campaign_id]
        
        # Update timestamps
        campaign['last_seen'] = event['timestamp']  # Update most recent activity
        
        # Update source IPs set
        source_ip = event.get('source_ip', 'unknown')
        campaign['source_ips'].add(source_ip)  # Add source IP (set ensures uniqueness)
        
        # Update techniques set
        campaign['techniques'].add(technique['id'])  # Add technique ID
        
        # Update chains list (keep recent ones)
        campaign['chains'].extend(chains[:2])  # Add first 2 chains
        # Limit chains list to last 10 to prevent memory bloat
        if len(campaign['chains']) > 10:
            campaign['chains'] = campaign['chains'][-10:]
        
        # Update targets set
        target_ip = event.get('destination_ip', 'unknown')
        campaign['targets'].add(target_ip)  # Add target IP
        
        # Update event count
        campaign['event_count'] += 1  # Increment event counter
    
    # Predict next possible attack steps
    def _predict_next_steps(self, chains: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Predict next possible attack steps based on detected chains
        
        Uses multiple information sources:
        - MITRE ATT&CK technique relationships
        - Historical attack patterns
        - Current campaign behavior
        
        Args:
            chains: List of detected attack chains for prediction
            
        Returns:
            List of predictions with details and confidence scores
        """
        # Initialize empty predictions list
        predictions = []
        
        # Check if there are chains to base predictions on
        if not chains:
            return predictions
        
        # Analyze each chain for prediction (limit to 5 chains for performance)
        for chain in chains[:5]:
            # Only predict for chains with at least 2 steps
            if chain['length'] >= 2:
                # Get last technique in the chain
                last_technique = chain['techniques'][-1]
                
                # Get likely next techniques from MITRE framework
                next_techniques = self._get_likely_next_techniques(last_technique, chain['pattern_name'])
                
                # Create prediction for each likely next technique
                for next_tech in next_techniques:
                    prediction = {
                        'based_on_chain': chain['pattern_name'],  # Which chain prediction is based on
                        'last_technique': last_technique,  # Last observed technique
                        'predicted_technique': next_tech['id'],  # Predicted next technique ID
                        'technique_name': next_tech['name'],  # Predicted technique name
                        'confidence': next_tech['confidence'],  # Prediction confidence
                        'reason': next_tech.get('reason', 'Common progression'),  # Reason for prediction
                        'recommended_defense': self._get_defense_for_technique(next_tech['id'])  # Recommended defenses
                    }
                    predictions.append(prediction)
        
        # Return all predictions
        return predictions
    
    # Get likely next techniques based on current technique
    def _get_likely_next_techniques(self, last_technique: str, pattern_name: str) -> List[Dict[str, Any]]:
        """
        Get likely next techniques based on current technique and pattern
        
        Uses progression patterns and historical data to determine
        what techniques attackers typically use next
        
        Args:
            last_technique: Last technique ID observed in the chain
            pattern_name: Name of the attack pattern for context
            
        Returns:
            List of likely next techniques with confidence scores
        """
        # Initialize list for next techniques
        next_techs = []
        
        # Define technique progression patterns
        # These are common sequences observed in real attacks
        progression_patterns = {
            'T1190': [  # After initial access (T1190)
                {'id': 'T1059', 'name': 'Command Execution', 'confidence': 0.8, 'reason': 'Common follow-up'},
                {'id': 'T1083', 'name': 'File Discovery', 'confidence': 0.6, 'reason': 'Reconnaissance'},
                {'id': 'T1005', 'name': 'Data from Local System', 'confidence': 0.5, 'reason': 'Data gathering'}
            ],
            'T1059': [  # After command execution (T1059)
                {'id': 'T1068', 'name': 'Privilege Escalation', 'confidence': 0.7, 'reason': 'Gain higher privileges'},
                {'id': 'T1021', 'name': 'Remote Services', 'confidence': 0.6, 'reason': 'Lateral movement'},
                {'id': 'T1070', 'name': 'Indicator Removal', 'confidence': 0.5, 'reason': 'Cover tracks'}
            ],
            'T1021': [  # After lateral movement (T1021)
                {'id': 'T1048', 'name': 'Exfiltration', 'confidence': 0.8, 'reason': 'Data theft'},
                {'id': 'T1059', 'name': 'Command Execution', 'confidence': 0.7, 'reason': 'Further execution'},
                {'id': 'T1070', 'name': 'Indicator Removal', 'confidence': 0.6, 'reason': 'Cleanup'}
            ]
        }
        
        # Get pattern-specific progressions
        # Check if pattern exists in loaded attack patterns
        if pattern_name in self.attack_patterns:
            # Get all sequences for this pattern
            pattern_sequences = self.attack_patterns[pattern_name]
            # Check each sequence in the pattern
            for sequence in pattern_sequences:
                # Check if last technique is in this sequence
                if last_technique in sequence:
                    # Get index of last technique in sequence
                    idx = sequence.index(last_technique)
                    # Check if there's a next technique in sequence
                    if idx < len(sequence) - 1:
                        # Get next technique ID from sequence
                        next_id = sequence[idx + 1]
                        # Check if technique exists in MITRE database
                        if next_id in self.mitre_techniques:
                            # Add next technique with high confidence
                            next_techs.append({
                                'id': next_id,
                                'name': self.mitre_techniques[next_id]['name'],
                                'confidence': 0.9,  # High confidence for pattern-based prediction
                                'reason': f'Next step in {pattern_name} pattern'
                            })
        
        # Add generic progressions if last technique has defined progressions
        if last_technique in progression_patterns:
            next_techs.extend(progression_patterns[last_technique])
        
        # Remove duplicates while preserving order
        seen_ids = set()  # Track seen technique IDs
        unique_techs = []  # List for unique techniques
        for tech in next_techs:
            if tech['id'] not in seen_ids:
                seen_ids.add(tech['id'])  # Mark as seen
                unique_techs.append(tech)  # Add to unique list
        
        # Return top 3 predictions (most likely next steps)
        return unique_techs[:3]
    
    # Get recommended defenses for specific MITRE technique
    def _get_defense_for_technique(self, technique_id: str) -> List[str]:
        """
        Get recommended defenses for MITRE technique
        
        Provides actionable defense recommendations based on
        MITRE ATT&CK technique mitigation guidance
        
        Args:
            technique_id: MITRE technique ID to get defenses for
            
        Returns:
            List of recommended defense actions
        """
        # Define defenses for specific techniques
        defenses = {
            'T1190': [  # Defenses for Exploit Public-Facing Application
                'Implement WAF (Web Application Firewall)',
                'Regular vulnerability scanning',
                'Input validation and sanitization',
                'Keep software updated'
            ],
            'T1059': [  # Defenses for Command and Scripting Interpreter
                'Restrict command execution permissions',
                'Implement application whitelisting',
                'Monitor command line activity',
                'Use endpoint detection and response (EDR)'
            ],
            'T1021': [  # Defenses for Remote Services
                'Network segmentation',
                'Monitor for unusual RDP/SSH connections',
                'Implement multi-factor authentication',
                'Regular review of service accounts'
            ],
            'T1048': [  # Defenses for Exfiltration Over Alternative Protocol
                'Monitor outbound network traffic',
                'Implement data loss prevention (DLP)',
                'Encrypt sensitive data',
                'Network traffic analysis'
            ]
        }
        
        # Return specific defenses if technique has them, otherwise generic defenses
        return defenses.get(technique_id, [
            'Monitor for suspicious activity',  # Generic monitoring
            'Review security logs regularly',  # Log review
            'Keep systems updated'  # Basic hygiene
        ])
    
    # Compute overall threat level from detected chains
    def _compute_chain_threat(self, chains: List[Dict[str, Any]]) -> float:
        """
        Compute overall threat level from detected chains
        
        Calculates a composite threat score based on:
        - Chain confidence
        - Chain length
        - Technique severity
        
        Args:
            chains: List of detected attack chains
            
        Returns:
            Threat level between 0 and 1
            0 = minimal threat, 1 = maximum threat
        """
        # No chains means minimal threat
        if not chains:
            return 0.1
        
        # Initialize list for threat scores
        threat_scores = []
        
        # Calculate threat score for each chain
        for chain in chains:
            # Base score from chain confidence (0.5 default if missing)
            base_score = chain.get('confidence', 0.5)
            
            # Adjust based on chain length
            # Longer chains are more threatening, max factor 1.0 at 10+ steps
            length_factor = min(1.0, chain.get('length', 1) / 10.0)
            
            # Adjust based on techniques used
            # More severe techniques increase threat
            technique_factor = self._get_technique_severity(chain.get('techniques', []))
            
            # Combined weighted score
            # 40% confidence, 30% length, 30% technique severity
            chain_score = base_score * 0.4 + length_factor * 0.3 + technique_factor * 0.3
            threat_scores.append(chain_score)
        
        # Return average threat score, capped at 1.0
        return float(min(1.0, np.mean(threat_scores)))
    
    # Get severity score for list of techniques
    def _get_technique_severity(self, techniques: List[str]) -> float:
        """
        Get severity score for list of techniques
        
        Assigns severity scores based on potential impact of techniques
        Higher scores for techniques with greater potential damage
        
        Args:
            techniques: List of MITRE technique IDs
            
        Returns:
            Average severity score between 0 and 1
        """
        # No techniques means medium severity (0.5)
        if not techniques:
            return 0.5
        
        # Define technique severities based on potential impact
        severities = {
            'T1190': 0.8,  # Initial access - high impact
            'T1059': 0.7,  # Execution - medium-high impact
            'T1068': 0.9,  # Privilege escalation - very high impact
            'T1021': 0.8,  # Lateral movement - high impact
            'T1048': 0.9,  # Exfiltration - very high impact
            'T1070': 0.6   # Defense evasion - medium impact
        }
        
        # Get severity score for each technique, default 0.5 if unknown
        tech_scores = [severities.get(tech, 0.5) for tech in techniques]
        # Return average severity, or 0.5 if no scores
        return float(np.mean(tech_scores)) if tech_scores else 0.5
    
    # Compute overall confidence in chain detection
    def _compute_chain_confidence(self, chains: List[Dict[str, Any]]) -> float:
        """
        Compute overall confidence in chain detection
        
        Calculates average confidence across all detected chains
        Higher average confidence means more reliable detections
        
        Args:
            chains: List of detected attack chains
            
        Returns:
            Average confidence score between 0 and 1
        """
        # No chains means low confidence (0.1)
        if not chains:
            return 0.1
        
        # Extract confidence from each chain, default 0.5 if missing
        confidences = [chain.get('confidence', 0.5) for chain in chains]
        # Return average confidence
        return float(np.mean(confidences))
    
    # Get recommended action based on analysis
    def _get_recommended_action(self, chains: List[Dict[str, Any]], predictions: List[Dict[str, Any]]) -> str:
        """
        Get recommended action based on detected chains
        
        Provides actionable guidance to security teams
        based on threat level and confidence
        
        Args:
            chains: Detected attack chains
            predictions: Predicted next attack steps
            
        Returns:
            Recommended action string with priority level
        """
        # No chains detected, recommend monitoring only
        if not chains:
            return "MONITOR - No attack chains detected"
        
        # Check for high-confidence chains (confidence > 0.8)
        high_conf_chains = [c for c in chains if c.get('confidence', 0) > 0.8]
        
        # If high-confidence chains exist
        if high_conf_chains:
            # Define critical techniques that require immediate action
            critical_techs = ['T1048', 'T1068', 'T1190']  # Exfiltration, privilege escalation, initial access
            
            # Check if any high-confidence chain contains critical techniques
            for chain in high_conf_chains:
                if any(tech in critical_techs for tech in chain.get('techniques', [])):
                    # Critical chain detected, recommend blocking
                    return "BLOCK - Critical attack chain detected"
            
            # High-confidence but not critical, recommend isolation
            return "ISOLATE - High-confidence attack chain, isolate affected systems"
        
        # Check for high-confidence predictions
        if predictions:
            high_conf_predictions = [p for p in predictions if p.get('confidence', 0) > 0.7]
            if high_conf_predictions:
                # High-confidence predictions, recommend preventive measures
                return "PREVENT - Implement defenses against predicted next steps"
        
        # Lower confidence detections, recommend investigation
        return "INVESTIGATE - Potential attack chain detected, needs investigation"
    
    # Generate error response for analysis failures
    def _error_response(self, error_message: str) -> Dict[str, Any]:
        """
        Generate error response when analysis fails
        
        Provides structured error information when
        analysis encounters exceptions
        
        Args:
            error_message: Error description from exception
            
        Returns:
            Error response dictionary with standard structure
        """
        return {
            'agent_id': self.agent_id,  # Agent identifier
            'agent_name': self.name,  # Agent name
            'error': error_message,  # Error description
            'chains_detected': [],  # Empty chains list
            'campaigns': [],  # Empty campaigns list
            'prediction': None,  # No predictions
            'reasoning_state': self.get_reasoning_state(),  # Current state
            'decision': {  # Default decision information
                'threat_level': 0.5,  # Medium threat level
                'confidence': 0.1,  # Low confidence due to error
                'evidence': [{'type': 'AGENT_ERROR', 'description': error_message}]  # Error evidence
            }
        }
    
    # Get detailed report for a specific campaign
    def get_campaign_report(self, campaign_id: str) -> Optional[Dict[str, Any]]:
        """
        Get detailed report for a campaign
        
        Provides comprehensive information about a specific campaign
        including timeline, techniques, and recommendations
        
        Args:
            campaign_id: Campaign identifier to get report for
            
        Returns:
            Campaign report dictionary with detailed information
            None if campaign not found
        """
        # Check if campaign exists
        if campaign_id not in self.campaigns:
            return None
        
        # Get campaign data
        campaign = self.campaigns[campaign_id]
        
        # Calculate campaign metrics
        duration = self._calculate_campaign_duration(campaign)  # Duration in hours
        impact_score = self._calculate_impact_score(campaign)  # Impact score 0-1
        
        # Generate timeline of campaign events
        timeline = self._generate_campaign_timeline(campaign)
        
        # Generate defense recommendations
        recommendations = self._generate_campaign_recommendations(campaign)
        
        # Build comprehensive report
        report = {
            'campaign_id': campaign_id,  # Campaign identifier
            'summary': {  # Summary statistics
                'start_time': campaign['start_time'],  # When campaign started
                'last_seen': campaign['last_seen'],  # Most recent activity
                'duration_hours': duration,  # Total duration
                'source_ips': list(campaign['source_ips']),  # List of source IPs
                'targets': list(campaign['targets']),  # List of targets
                'event_count': campaign['event_count'],  # Number of events
                'unique_techniques': len(campaign['techniques']),  # Number of techniques
                'chains_detected': len(campaign['chains']),  # Number of chains
                'impact_score': impact_score  # Calculated impact
            },
            'techniques_used': [  # Detailed technique information
                {
                    'id': tech_id,  # Technique ID
                    'name': self.mitre_techniques.get(tech_id, {}).get('name', 'Unknown')  # Technique name
                }
                for tech_id in campaign['techniques']  # For each technique in campaign
            ],
            'detected_chains': campaign['chains'][:5],  # Top 5 chains (limit for report size)
            'timeline': timeline,  # Event timeline
            'recommendations': recommendations,  # Defense recommendations
            'status': 'ACTIVE' if self._is_campaign_active(campaign) else 'INACTIVE'  # Campaign status
        }
        
        return report
    
    # Calculate campaign duration in hours
    def _calculate_campaign_duration(self, campaign: Dict[str, Any]) -> float:
        """
        Calculate campaign duration in hours
        
        Args:
            campaign: Campaign dictionary with start_time and last_seen
            
        Returns:
            Duration in hours, rounded to 2 decimal places
        """
        try:
            # Parse start time
            start_str = campaign['start_time']
            if start_str.endswith('Z'):
                start_str = start_str[:-1] + '+00:00'
            start = datetime.fromisoformat(start_str)
            
            # Parse last seen time
            last_seen_str = campaign['last_seen']
            if last_seen_str.endswith('Z'):
                last_seen_str = last_seen_str[:-1] + '+00:00'
            end = datetime.fromisoformat(last_seen_str)
            
            # Calculate duration in hours
            duration = (end - start).total_seconds() / 3600
            # Round to 2 decimal places
            return round(duration, 2)
        except (ValueError, TypeError, KeyError):
            # If parsing fails, return 0 duration
            return 0.0
    
    # Calculate impact score for campaign
    def _calculate_impact_score(self, campaign: Dict[str, Any]) -> float:
        """
        Calculate impact score for campaign (0-1)
        
        Composite score based on multiple factors:
        - Number of source IPs
        - Number of targets
        - Techniques used
        - Event count
        
        Args:
            campaign: Campaign dictionary
            
        Returns:
            Impact score between 0 and 1
        """
        # Initialize score
        score = 0.0
        
        # Factor 1: Number of source IPs (more IPs = higher impact)
        # Cap at 10 IPs for scoring (1.0 at 10+ IPs)
        ip_factor = min(1.0, len(campaign['source_ips']) / 10.0)
        score += ip_factor * 0.2  # 20% weight
        
        # Factor 2: Number of targets (more targets = higher impact)
        # Cap at 5 targets for scoring (1.0 at 5+ targets)
        target_factor = min(1.0, len(campaign['targets']) / 5.0)
        score += target_factor * 0.3  # 30% weight
        
        # Factor 3: Techniques used (more severe techniques = higher impact)
        tech_severity = self._get_technique_severity(list(campaign['techniques']))
        score += tech_severity * 0.4  # 40% weight
        
        # Factor 4: Event count (more events = higher impact)
        # Cap at 50 events for scoring (1.0 at 50+ events)
        event_factor = min(1.0, campaign['event_count'] / 50.0)
        score += event_factor * 0.1  # 10% weight
        
        # Ensure score doesn't exceed 1.0
        return min(1.0, score)
    
    # Generate timeline of campaign events
    def _generate_campaign_timeline(self, campaign: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Generate timeline of campaign events
        
        Creates chronological list of events from campaign chains
        
        Args:
            campaign: Campaign dictionary with chains
            
        Returns:
            Timeline list of events in chronological order
        """
        # Initialize timeline list
        timeline = []
        
        # Extract events from chains (limit to 10 chains for performance)
        for chain in campaign['chains'][:10]:
            # Get events from chain if available
            for event in chain.get('events', []):
                # Add event to timeline with relevant information
                timeline.append({
                    'timestamp': event['timestamp'],  # When event occurred
                    'technique': event['technique'],  # MITRE technique
                    'description': event['description'],  # Event description
                    'severity': event.get('severity', 'medium'),  # Severity level
                    'chain': chain.get('pattern_name', 'unknown')  # Which chain event belongs to
                })
        
        # Sort timeline by timestamp (chronological order)
        timeline.sort(key=lambda x: x['timestamp'])
        
        # Return first 20 events (limit for report size)
        return timeline[:20]
    
    # Generate recommendations for dealing with campaign
    def _generate_campaign_recommendations(self, campaign: Dict[str, Any]) -> List[str]:
        """
        Generate recommendations for dealing with campaign
        
        Provides actionable defense recommendations based on
        techniques used and campaign characteristics
        
        Args:
            campaign: Campaign dictionary
            
        Returns:
            List of defense recommendations
        """
        # Initialize recommendations list
        recommendations = []
        
        # Based on techniques used in campaign
        for tech_id in campaign['techniques']:
            # Get defenses for each technique
            defenses = self._get_defense_for_technique(tech_id)
            # Add top 2 defenses per technique
            recommendations.extend(defenses[:2])
        
        # General recommendations based on campaign characteristics
        if len(campaign['source_ips']) > 1:
            # Multiple source IPs, recommend blocking all
            recommendations.append("Block all source IPs associated with campaign")
        
        if len(campaign['targets']) > 1:
            # Multiple targets, recommend investigation
            recommendations.append("Isolate and investigate all affected targets")
        
        # Remove duplicate recommendations
        unique_recommendations = []
        seen = set()  # Track seen recommendations
        for rec in recommendations:
            if rec not in seen:
                seen.add(rec)  # Mark as seen
                unique_recommendations.append(rec)  # Add to unique list
        
        # Return top 5 recommendations
        return unique_recommendations[:5]
    
    # Check if campaign is still active
    def _is_campaign_active(self, campaign: Dict[str, Any]) -> bool:
        """
        Check if campaign is still active
        
        Determines if campaign has been recently active
        based on last seen timestamp
        
        Args:
            campaign: Campaign dictionary with last_seen timestamp
            
        Returns:
            Boolean indicating if campaign is active
            True if seen in last 24 hours, False otherwise
        """
        try:
            # Parse last seen timestamp
            last_seen_str = campaign['last_seen']
            if last_seen_str.endswith('Z'):
                last_seen_str = last_seen_str[:-1] + '+00:00'
            last_seen = datetime.fromisoformat(last_seen_str)
            
            # Calculate time since last activity
            time_since_last = (datetime.now() - last_seen).total_seconds()
            
            # Consider active if seen in last 24 hours (86400 seconds)
            return time_since_last < 86400
        except (ValueError, TypeError, KeyError):
            # If parsing fails, assume inactive
            return False
    
    # Get comprehensive agent status
    def get_agent_status(self) -> Dict[str, Any]:
        """
        Get comprehensive agent status
        
        Provides detailed information about agent state,
        metrics, and configuration
        
        Returns:
            Dictionary with agent status information
        """
        # Calculate active campaigns
        active_campaigns = len([c for c in self.campaigns.values() if self._is_campaign_active(c)])
        
        # Calculate average events per campaign
        avg_events = 0.0
        if self.campaigns:
            # Extract event counts from all campaigns
            event_counts = [c['event_count'] for c in self.campaigns.values()]
            # Calculate mean
            avg_events = float(np.mean(event_counts))
        
        # Build status dictionary
        return {
            'agent_id': self.agent_id,  # Agent identifier
            'name': self.name,  # Agent name
            'status': 'ACTIVE',  # Agent operational status
            'confidence': self.confidence,  # Agent confidence level from parent class
            'metrics': self.metrics,  # Performance and detection metrics
            'campaigns': {  # Campaign statistics
                'active': active_campaigns,  # Number of currently active campaigns
                'total': len(self.campaigns),  # Total number of campaigns
                'avg_events_per_campaign': avg_events  # Average events per campaign
            },
            'detection_capabilities': {  # Capability information
                'mitre_techniques': len(self.mitre_techniques),  # Number of MITRE techniques loaded
                'attack_patterns': sum(len(patterns) for patterns in self.attack_patterns.values()),  # Total pattern sequences
                'avg_chain_length': self.metrics['avg_chain_length'],  # Average chain length detected
                'correlation_window_hours': self.correlation_window / 3600  # Correlation window in hours
            },
            'config': {  # Configuration information
                'thresholds': self.thresholds,  # Detection thresholds
                'max_sequence_length': self.max_sequence_length,  # Maximum sequence length
                'min_chain_length': self.thresholds['min_chain_length']  # Minimum chain length
            }
        }