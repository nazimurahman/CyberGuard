# src/agents/exploit_chain_agent.py
"""
Exploit Chain Reasoning Agent
Purpose: Detects multi-step attack chains, privilege escalation attempts, and lateral movement
Techniques: Attack graph analysis, MITRE ATT&CK mapping, correlation analysis, sequence detection
"""

from typing import Dict, List, Any, Set, Tuple
from datetime import datetime, timedelta
import networkx as nx
import numpy as np
import time
from collections import defaultdict, deque

from .base_agent import SecurityAgent, AgentCapability

class ExploitChainReasoningAgent(SecurityAgent):
    """
    Exploit Chain Reasoning Agent
    
    This agent specializes in detecting:
    1. Multi-step attack chains
    2. Privilege escalation attempts
    3. Lateral movement
    4. Persistence mechanisms
    5. Defense evasion techniques
    6. Command and control (C2) communication
    7. Data exfiltration attempts
    8. Attack campaign correlation
    
    Techniques used:
    - MITRE ATT&CK framework mapping
    - Attack graph analysis
    - Sequence pattern recognition
    - Temporal correlation
    - Behavioral chain analysis
    - Threat intelligence correlation
    - Graph database queries
    """
    
    def __init__(self, agent_id: str = "exploit_chain_001"):
        super().__init__(
            agent_id=agent_id,
            name="Exploit Chain Reasoning Agent",
            state_dim=1024  # Larger state for complex reasoning
        )
        
        # Add exploit chain detection capability
        self.capabilities.append(AgentCapability.EXPLOIT_CHAIN_DETECTION)
        
        # MITRE ATT&CK techniques database
        self.mitre_techniques = self._load_mitre_techniques()
        
        # Attack chain patterns
        self.attack_patterns = self._load_attack_patterns()
        
        # Attack graph for correlation
        self.attack_graph = nx.DiGraph()
        
        # Event sequences for detection
        self.event_sequences = defaultdict(deque)
        self.max_sequence_length = 100
        
        # Time window for correlation (seconds)
        self.correlation_window = 3600  # 1 hour
        
        # Detection thresholds
        self.thresholds = {
            'chain_confidence': 0.7,
            'temporal_correlation': 0.8,
            'behavioral_similarity': 0.6,
            'min_chain_length': 3,
            'max_time_gap': 300,  # 5 minutes between steps
        }
        
        # Campaign tracking
        self.campaigns = {}
        self.campaign_counter = 0
        
        # Metrics
        self.metrics = {
            'events_processed': 0,
            'chains_detected': 0,
            'campaigns_identified': 0,
            'false_positives': 0,
            'avg_chain_length': 0.0,
            'graph_nodes': 0,
            'graph_edges': 0
        }
    
    def _load_mitre_techniques(self) -> Dict[str, Dict]:
        """
        Load MITRE ATT&CK techniques
        
        MITRE ATT&CK is a knowledge base of adversary tactics and techniques
        """
        # In production, load from MITRE ATT&CK JSON
        # Simplified version for demonstration
        return {
            'T1190': {
                'id': 'T1190',
                'name': 'Exploit Public-Facing Application',
                'tactic': 'Initial Access',
                'description': 'Adversaries may attempt to exploit a weakness in an Internet-facing computer or program.',
                'examples': ['Web shell upload', 'SQL injection', 'XSS to RCE']
            },
            'T1133': {
                'id': 'T1133',
                'name': 'External Remote Services',
                'tactic': 'Persistence',
                'description': 'Adversaries may use external remote services to maintain access to systems.',
                'examples': ['RDP', 'VPN', 'SSH']
            },
            'T1059': {
                'id': 'T1059',
                'name': 'Command and Scripting Interpreter',
                'tactic': 'Execution',
                'description': 'Adversaries may abuse command and script interpreters to execute commands.',
                'examples': ['PowerShell', 'Bash', 'Python']
            },
            'T1068': {
                'id': 'T1068',
                'name': 'Exploitation for Privilege Escalation',
                'tactic': 'Privilege Escalation',
                'description': 'Adversaries may exploit software vulnerabilities to elevate privileges.',
                'examples': ['Local privilege escalation', 'Kernel exploits']
            },
            'T1021': {
                'id': 'T1021',
                'name': 'Remote Services',
                'tactic': 'Lateral Movement',
                'description': 'Adversaries may use remote services to move between systems.',
                'examples': ['SMB', 'RPC', 'WinRM']
            },
            'T1048': {
                'id': 'T1048',
                'name': 'Exfiltration Over Alternative Protocol',
                'tactic': 'Exfiltration',
                'description': 'Adversaries may steal data by exfiltrating it over a different protocol.',
                'examples': ['DNS tunneling', 'HTTP upload', 'ICMP']
            },
            'T1070': {
                'id': 'T1070',
                'name': 'Indicator Removal on Host',
                'tactic': 'Defense Evasion',
                'description': 'Adversaries may delete or modify generated artifacts to avoid detection.',
                'examples': ['Clear logs', 'Delete files', 'Timestomping']
            }
        }
    
    def _load_attack_patterns(self) -> Dict[str, List[List[str]]]:
        """
        Load known attack chain patterns
        
        Each pattern is a sequence of MITRE ATT&CK techniques
        representing a common attack flow
        """
        return {
            'web_shell_attack': [
                ['T1190', 'T1059', 'T1068', 'T1021', 'T1048'],
                ['T1190', 'T1059', 'T1133', 'T1048'],
                ['T1190', 'T1059', 'T1070', 'T1048']
            ],
            'ransomware_attack': [
                ['T1133', 'T1059', 'T1021', 'T1070'],
                ['T1190', 'T1059', 'T1021', 'T1070']
            ],
            'data_theft': [
                ['T1190', 'T1059', 'T1048'],
                ['T1133', 'T1059', 'T1048'],
                ['T1133', 'T1021', 'T1048']
            ],
            'lateral_movement': [
                ['T1190', 'T1059', 'T1021', 'T1021', 'T1021'],
                ['T1133', 'T1021', 'T1021', 'T1068']
            ]
        }
    
    def analyze(self, security_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Analyze security events for exploit chains
        
        Process flow:
        1. Extract and classify events
        2. Map to MITRE ATT&CK techniques
        3. Add to attack graph
        4. Correlate with existing sequences
        5. Detect attack chains
        6. Identify campaigns
        7. Predict next steps
        """
        start_time = time.time()
        
        try:
            # Extract events from security data
            events = self._extract_events(security_data)
            
            if not events:
                return {
                    'agent_id': self.agent_id,
                    'agent_name': self.name,
                    'chains_detected': [],
                    'campaigns': [],
                    'prediction': None
                }
            
            # Update metrics
            self.metrics['events_processed'] += len(events)
            
            # Process each event
            all_chains = []
            all_campaigns = []
            
            for event in events:
                # Map event to MITRE ATT&CK technique
                technique = self._map_to_mitre(event)
                
                if technique:
                    # Add to attack graph
                    self._add_to_attack_graph(event, technique)
                    
                    # Add to event sequences
                    self._add_to_sequences(event, technique)
                    
                    # Detect chains for this event
                    chains = self._detect_chains(event, technique)
                    all_chains.extend(chains)
                    
                    # Update campaigns
                    campaigns = self._update_campaigns(event, technique, chains)
                    all_campaigns.extend(campaigns)
            
            # Update graph metrics
            self.metrics['graph_nodes'] = len(self.attack_graph.nodes())
            self.metrics['graph_edges'] = len(self.attack_graph.edges())
            
            # Predict next possible attack steps
            predictions = self._predict_next_steps(all_chains)
            
            # Calculate processing time
            processing_time = time.time() - start_time
            
            # Generate response
            response = {
                'agent_id': self.agent_id,
                'agent_name': self.name,
                'analysis_timestamp': datetime.now().isoformat(),
                'processing_time': processing_time,
                'events_processed': len(events),
                'chains_detected': all_chains[:10],  # Limit to 10 chains
                'campaigns_identified': list(set(all_campaigns)),
                'predictions': predictions,
                'attack_graph_summary': {
                    'nodes': self.metrics['graph_nodes'],
                    'edges': self.metrics['graph_edges'],
                    'density': nx.density(self.attack_graph) if self.attack_graph else 0
                },
                'recommended_action': self._get_recommended_action(all_chains, predictions),
                'reasoning_state': self.get_reasoning_state(),
                'decision': {
                    'threat_level': self._compute_chain_threat(all_chains),
                    'confidence': self._compute_chain_confidence(all_chains),
                    'evidence': all_chains[:3] if all_chains else []
                }
            }
            
            # Update agent confidence
            if all_chains:
                certainty = min(0.9, len(all_chains) * 0.1)
                self.update_confidence({'certainty': certainty})
            
            return response
            
        except Exception as e:
            print(f"❌ {self.name}: Exploit chain analysis error: {e}")
            return self._error_response(str(e))
    
    def _extract_events(self, security_data: Dict) -> List[Dict]:
        """
        Extract security events from data
        
        Events can come from:
        - Log files
        - IDS/IPS alerts
        - Endpoint detection
        - Network monitoring
        - Application logs
        """
        events = []
        
        # Check for direct events
        if 'events' in security_data:
            events.extend(security_data['events'])
        
        # Extract from agent analyses
        for key in security_data.keys():
            if key.endswith('_analysis'):
                analysis = security_data[key]
                if isinstance(analysis, dict) and 'findings' in analysis:
                    event = self._create_event_from_analysis(analysis, key)
                    events.append(event)
        
        # Filter valid events
        valid_events = []
        for event in events:
            if self._is_valid_event(event):
                valid_events.append(event)
        
        return valid_events
    
    def _create_event_from_analysis(self, analysis: Dict, source: str) -> Dict:
        """
        Create standardized event from agent analysis
        """
        event = {
            'timestamp': analysis.get('analysis_timestamp', datetime.now().isoformat()),
            'source': source,
            'source_ip': analysis.get('ip_address', 'unknown'),
            'destination_ip': analysis.get('target_ip', 'unknown'),
            'event_type': analysis.get('type', 'security_alert'),
            'severity': analysis.get('severity', 'medium'),
            'description': analysis.get('description', 'Security event detected'),
            'raw_data': analysis
        }
        
        # Extract MITRE technique indicators
        if 'detections' in analysis:
            for detection in analysis['detections']:
                if 'type' in detection:
                    event['technique_hints'] = event.get('technique_hints', [])
                    event['technique_hints'].append(detection['type'])
        
        return event
    
    def _is_valid_event(self, event: Dict) -> bool:
        """
        Validate event has required fields
        """
        required = ['timestamp', 'event_type', 'description']
        
        for field in required:
            if field not in event:
                return False
        
        # Validate timestamp
        try:
            datetime.fromisoformat(event['timestamp'].replace('Z', '+00:00'))
        except (ValueError, TypeError):
            return False
        
        return True
    
    def _map_to_mitre(self, event: Dict) -> Optional[Dict]:
        """
        Map event to MITRE ATT&CK technique
        
        Uses pattern matching and keyword analysis
        """
        description = event.get('description', '').lower()
        event_type = event.get('event_type', '').lower()
        
        # Check for technique hints
        technique_hints = event.get('technique_hints', [])
        
        # Map based on keywords and patterns
        mapping_rules = [
            # Initial Access
            (['web shell', 'php shell', 'backdoor'], 'T1190'),
            (['sql injection', 'sqli'], 'T1190'),
            (['xss', 'cross-site scripting'], 'T1190'),
            (['brute force', 'password spray'], 'T1110'),
            
            # Execution
            (['command execution', 'cmd.exe', 'powershell'], 'T1059'),
            (['python', 'perl', 'ruby script'], 'T1059'),
            (['bash', 'shell script'], 'T1059'),
            
            # Persistence
            (['scheduled task', 'cron job', 'startup'], 'T1053'),
            (['service installation', 'daemon'], 'T1543'),
            (['registry', 'run key'], 'T1547'),
            
            # Privilege Escalation
            (['privilege escalation', 'sudo', 'runas'], 'T1068'),
            (['kernel exploit', 'local exploit'], 'T1068'),
            
            # Lateral Movement
            (['lateral movement', 'psexec', 'wmic'], 'T1021'),
            (['rdp', 'remote desktop'], 'T1021'),
            (['ssh', 'secure shell'], 'T1021'),
            
            # Exfiltration
            (['data exfiltration', 'data theft'], 'T1048'),
            (['dns tunneling', 'dns exfiltration'], 'T1048'),
            (['http upload', 'ftp transfer'], 'T1048'),
            
            # Defense Evasion
            (['log clearing', 'event log'], 'T1070'),
            (['file deletion', 'evidence removal'], 'T1070'),
            (['timestomping', 'timestamp modification'], 'T1070')
        ]
        
        for keywords, technique_id in mapping_rules:
            for keyword in keywords:
                if (keyword in description or 
                    keyword in event_type or
                    any(keyword in str(hint).lower() for hint in technique_hints)):
                    
                    if technique_id in self.mitre_techniques:
                        technique = self.mitre_techniques[technique_id].copy()
                        technique['confidence'] = 0.7
                        technique['matched_keyword'] = keyword
                        return technique
        
        # If no specific match, use generic mapping
        if 'malware' in description or 'virus' in description:
            return {
                'id': 'T1203',
                'name': 'Exploitation for Client Execution',
                'tactic': 'Execution',
                'confidence': 0.5,
                'matched_keyword': 'malware'
            }
        
        return None
    
    def _add_to_attack_graph(self, event: Dict, technique: Dict):
        """
        Add event to attack graph for correlation
        
        The attack graph connects:
        - Sources and destinations
        - Techniques and tactics
        - Timelines and sequences
        """
        # Create node IDs
        source_node = f"src:{event.get('source_ip', 'unknown')}"
        dest_node = f"dst:{event.get('destination_ip', 'unknown')}"
        technique_node = f"tech:{technique['id']}"
        
        # Add nodes
        self.attack_graph.add_node(source_node, type='source', ip=event.get('source_ip'))
        self.attack_graph.add_node(dest_node, type='destination', ip=event.get('destination_ip'))
        self.attack_graph.add_node(technique_node, type='technique', **technique)
        
        # Add edges with event data
        self.attack_graph.add_edge(
            source_node, technique_node,
            timestamp=event['timestamp'],
            event_type=event['event_type'],
            severity=event.get('severity', 'medium')
        )
        
        self.attack_graph.add_edge(
            technique_node, dest_node,
            timestamp=event['timestamp'],
            event_type=event['event_type'],
            severity=event.get('severity', 'medium')
        )
    
    def _add_to_sequences(self, event: Dict, technique: Dict):
        """
        Add event to temporal sequences for chain detection
        """
        source_ip = event.get('source_ip', 'unknown')
        
        if source_ip not in self.event_sequences:
            self.event_sequences[source_ip] = deque(maxlen=self.max_sequence_length)
        
        sequence_entry = {
            'timestamp': event['timestamp'],
            'technique': technique['id'],
            'technique_name': technique['name'],
            'event_type': event['event_type'],
            'description': event['description'],
            'severity': event.get('severity', 'medium')
        }
        
        self.event_sequences[source_ip].append(sequence_entry)
    
    def _detect_chains(self, event: Dict, technique: Dict) -> List[Dict]:
        """
        Detect attack chains involving this event
        
        Looks for patterns of techniques over time
        """
        chains = []
        source_ip = event.get('source_ip', 'unknown')
        
        if source_ip not in self.event_sequences:
            return chains
        
        sequence = list(self.event_sequences[source_ip])
        
        # Check against known attack patterns
        for pattern_name, pattern_sequences in self.attack_patterns.items():
            for pattern_sequence in pattern_sequences:
                chain = self._match_pattern(sequence, pattern_sequence, pattern_name)
                if chain:
                    chains.append(chain)
        
        # Detect emerging chains (not in known patterns)
        emerging_chains = self._detect_emerging_chains(sequence)
        chains.extend(emerging_chains)
        
        return chains
    
    def _match_pattern(self, sequence: List[Dict], pattern: List[str], pattern_name: str) -> Optional[Dict]:
        """
        Match sequence against attack pattern
        
        Uses sequence alignment with time constraints
        """
        if len(sequence) < len(pattern):
            return None
        
        # Convert sequence to technique IDs
        sequence_techniques = [event['technique'] for event in sequence]
        
        # Find pattern in sequence
        for i in range(len(sequence_techniques) - len(pattern) + 1):
            window = sequence_techniques[i:i + len(pattern)]
            
            # Check if window matches pattern
            if self._sequences_match(window, pattern):
                # Check time constraints
                window_events = sequence[i:i + len(pattern)]
                if self._check_time_constraints(window_events):
                    
                    # Calculate confidence
                    confidence = self._calculate_chain_confidence(window_events, pattern)
                    
                    if confidence > self.thresholds['chain_confidence']:
                        return {
                            'pattern_name': pattern_name,
                            'techniques': pattern,
                            'events': window_events,
                            'confidence': confidence,
                            'start_time': window_events[0]['timestamp'],
                            'end_time': window_events[-1]['timestamp'],
                            'length': len(pattern)
                        }
        
        return None
    
    def _sequences_match(self, window: List[str], pattern: List[str]) -> bool:
        """
        Check if window matches pattern
        
        Allows for some flexibility in matching
        """
        if len(window) != len(pattern):
            return False
        
        # Exact match or partial match
        matches = 0
        for w, p in zip(window, pattern):
            if w == p:
                matches += 1
        
        # Require at least 70% match
        return matches / len(pattern) >= 0.7
    
    def _check_time_constraints(self, events: List[Dict]) -> bool:
        """
        Check if events meet time constraints for a chain
        
        Events in a chain should be close in time
        """
        if len(events) < 2:
            return True
        
        # Convert timestamps
        timestamps = []
        for event in events:
            try:
                dt = datetime.fromisoformat(event['timestamp'].replace('Z', '+00:00'))
                timestamps.append(dt.timestamp())
            except:
                return False
        
        # Check time gaps
        for i in range(1, len(timestamps)):
            time_gap = timestamps[i] - timestamps[i-1]
            if time_gap > self.thresholds['max_time_gap']:
                return False
        
        return True
    
    def _calculate_chain_confidence(self, events: List[Dict], pattern: List[str]) -> float:
        """
        Calculate confidence score for detected chain
        """
        if not events:
            return 0.0
        
        confidence_factors = []
        
        # Technique match factor
        technique_matches = sum(1 for e, p in zip(events, pattern) if e['technique'] == p)
        technique_factor = technique_matches / len(pattern)
        confidence_factors.append(technique_factor)
        
        # Time proximity factor
        timestamps = []
        for event in events:
            try:
                dt = datetime.fromisoformat(event['timestamp'].replace('Z', '+00:00'))
                timestamps.append(dt.timestamp())
            except:
                timestamps.append(time.time())
        
        if len(timestamps) > 1:
            total_time = timestamps[-1] - timestamps[0]
            time_factor = 1.0 - min(1.0, total_time / (self.thresholds['max_time_gap'] * len(events)))
            confidence_factors.append(time_factor)
        
        # Severity factor
        severities = {'low': 0.3, 'medium': 0.6, 'high': 0.9, 'critical': 1.0}
        avg_severity = np.mean([severities.get(e.get('severity', 'medium'), 0.5) for e in events])
        confidence_factors.append(avg_severity)
        
        # Return average confidence
        return np.mean(confidence_factors)
    
    def _detect_emerging_chains(self, sequence: List[Dict]) -> List[Dict]:
        """
        Detect emerging chains not in known patterns
        
        Uses sequence mining and behavioral analysis
        """
        chains = []
        
        if len(sequence) < self.thresholds['min_chain_length']:
            return chains
        
        # Look for repeating patterns
        for chain_length in range(self.thresholds['min_chain_length'], min(6, len(sequence))):
            for i in range(len(sequence) - chain_length + 1):
                window = sequence[i:i + chain_length]
                
                # Check if this window forms a meaningful chain
                if self._is_meaningful_chain(window):
                    confidence = self._calculate_emerging_chain_confidence(window)
                    
                    if confidence > self.thresholds['chain_confidence']:
                        chains.append({
                            'pattern_name': 'emerging_chain',
                            'techniques': [e['technique'] for e in window],
                            'events': window,
                            'confidence': confidence,
                            'start_time': window[0]['timestamp'],
                            'end_time': window[-1]['timestamp'],
                            'length': chain_length
                        })
        
        return chains
    
    def _is_meaningful_chain(self, events: List[Dict]) -> bool:
        """
        Check if events form a meaningful attack chain
        
        Criteria:
        1. Multiple different techniques
        2. Logical progression (e.g., access → execution → persistence)
        3. Not just repeated same event
        """
        if len(events) < 2:
            return False
        
        # Check for different techniques
        techniques = set(event['technique'] for event in events)
        if len(techniques) < 2:
            return False
        
        # Check time constraints
        if not self._check_time_constraints(events):
            return False
        
        # Check for logical progression (simplified)
        # In production, use MITRE tactic progression
        return True
    
    def _calculate_emerging_chain_confidence(self, events: List[Dict]) -> float:
        """
        Calculate confidence for emerging chain
        """
        return self._calculate_chain_confidence(events, [e['technique'] for e in events])
    
    def _update_campaigns(self, event: Dict, technique: Dict, chains: List[Dict]) -> List[str]:
        """
        Update campaigns with new event and chains
        
        Campaigns group related attacks by:
        - Source IP
        - Techniques used
        - Timeframe
        - Targets
        """
        campaign_ids = []
        source_ip = event.get('source_ip', 'unknown')
        
        # Check existing campaigns
        for campaign_id, campaign in self.campaigns.items():
            if self._event_belongs_to_campaign(event, technique, campaign):
                self._update_campaign(campaign_id, event, technique, chains)
                campaign_ids.append(campaign_id)
        
        # Create new campaign if no match
        if not campaign_ids and chains:
            new_campaign_id = f"campaign_{self.campaign_counter:04d}"
            self.campaign_counter += 1
            
            self.campaigns[new_campaign_id] = {
                'id': new_campaign_id,
                'start_time': event['timestamp'],
                'last_seen': event['timestamp'],
                'source_ips': {source_ip},
                'techniques': {technique['id']},
                'chains': chains[:5],  # Keep first 5 chains
                'event_count': 1,
                'targets': {event.get('destination_ip', 'unknown')}
            }
            
            self.metrics['campaigns_identified'] += 1
            campaign_ids.append(new_campaign_id)
        
        return campaign_ids
    
    def _event_belongs_to_campaign(self, event: Dict, technique: Dict, campaign: Dict) -> bool:
        """
        Check if event belongs to existing campaign
        
        Criteria:
        1. Same source IP or related IPs
        2. Similar techniques
        3. Within time window
        """
        source_ip = event.get('source_ip', 'unknown')
        event_time = datetime.fromisoformat(event['timestamp'].replace('Z', '+00:00'))
        
        # Check time window
        last_seen = datetime.fromisoformat(campaign['last_seen'].replace('Z', '+00:00'))
        time_diff = (event_time - last_seen).total_seconds()
        
        if time_diff > self.correlation_window:
            return False
        
        # Check source IP
        if source_ip in campaign['source_ips']:
            return True
        
        # Check technique similarity
        if technique['id'] in campaign['techniques']:
            return True
        
        # Check if IPs are related (same subnet, etc.)
        # Simplified for demonstration
        return False
    
    def _update_campaign(self, campaign_id: str, event: Dict, technique: Dict, chains: List[Dict]):
        """
        Update existing campaign with new event
        """
        campaign = self.campaigns[campaign_id]
        
        # Update timestamps
        campaign['last_seen'] = event['timestamp']
        
        # Update source IPs
        source_ip = event.get('source_ip', 'unknown')
        campaign['source_ips'].add(source_ip)
        
        # Update techniques
        campaign['techniques'].add(technique['id'])
        
        # Update chains
        campaign['chains'].extend(chains[:2])  # Add first 2 chains
        if len(campaign['chains']) > 10:
            campaign['chains'] = campaign['chains'][-10:]  # Keep last 10
        
        # Update targets
        target_ip = event.get('destination_ip', 'unknown')
        campaign['targets'].add(target_ip)
        
        # Update event count
        campaign['event_count'] += 1
    
    def _predict_next_steps(self, chains: List[Dict]) -> List[Dict]:
        """
        Predict next possible attack steps based on detected chains
        
        Uses:
        - MITRE ATT&CK technique relationships
        - Historical attack patterns
        - Current campaign behavior
        """
        predictions = []
        
        if not chains:
            return predictions
        
        # Analyze each chain for prediction
        for chain in chains[:5]:  # Limit to 5 chains
            if chain['length'] >= 2:
                last_technique = chain['techniques'][-1]
                
                # Get likely next techniques from MITRE framework
                next_techniques = self._get_likely_next_techniques(last_technique, chain['pattern_name'])
                
                for next_tech in next_techniques:
                    prediction = {
                        'based_on_chain': chain['pattern_name'],
                        'last_technique': last_technique,
                        'predicted_technique': next_tech['id'],
                        'technique_name': next_tech['name'],
                        'confidence': next_tech['confidence'],
                        'reason': next_tech.get('reason', 'Common progression'),
                        'recommended_defense': self._get_defense_for_technique(next_tech['id'])
                    }
                    predictions.append(prediction)
        
        return predictions
    
    def _get_likely_next_techniques(self, last_technique: str, pattern_name: str) -> List[Dict]:
        """
        Get likely next techniques based on current technique and pattern
        """
        next_techs = []
        
        # Define technique progression patterns
        progression_patterns = {
            'T1190': [  # After initial access
                {'id': 'T1059', 'name': 'Command Execution', 'confidence': 0.8, 'reason': 'Common follow-up'},
                {'id': 'T1083', 'name': 'File Discovery', 'confidence': 0.6, 'reason': 'Reconnaissance'},
                {'id': 'T1005', 'name': 'Data from Local System', 'confidence': 0.5, 'reason': 'Data gathering'}
            ],
            'T1059': [  # After command execution
                {'id': 'T1068', 'name': 'Privilege Escalation', 'confidence': 0.7, 'reason': 'Gain higher privileges'},
                {'id': 'T1021', 'name': 'Remote Services', 'confidence': 0.6, 'reason': 'Lateral movement'},
                {'id': 'T1070', 'name': 'Indicator Removal', 'confidence': 0.5, 'reason': 'Cover tracks'}
            ],
            'T1021': [  # After lateral movement
                {'id': 'T1048', 'name': 'Exfiltration', 'confidence': 0.8, 'reason': 'Data theft'},
                {'id': 'T1059', 'name': 'Command Execution', 'confidence': 0.7, 'reason': 'Further execution'},
                {'id': 'T1070', 'name': 'Indicator Removal', 'confidence': 0.6, 'reason': 'Cleanup'}
            ]
        }
        
        # Get pattern-specific progressions
        if pattern_name in self.attack_patterns:
            pattern_sequences = self.attack_patterns[pattern_name]
            for sequence in pattern_sequences:
                if last_technique in sequence:
                    idx = sequence.index(last_technique)
                    if idx < len(sequence) - 1:
                        next_id = sequence[idx + 1]
                        if next_id in self.mitre_techniques:
                            next_techs.append({
                                'id': next_id,
                                'name': self.mitre_techniques[next_id]['name'],
                                'confidence': 0.9,
                                'reason': f'Next step in {pattern_name} pattern'
                            })
        
        # Add generic progressions
        if last_technique in progression_patterns:
            next_techs.extend(progression_patterns[last_technique])
        
        # Remove duplicates
        seen_ids = set()
        unique_techs = []
        for tech in next_techs:
            if tech['id'] not in seen_ids:
                seen_ids.add(tech['id'])
                unique_techs.append(tech)
        
        return unique_techs[:3]  # Return top 3 predictions
    
    def _get_defense_for_technique(self, technique_id: str) -> List[str]:
        """
        Get recommended defenses for MITRE technique
        """
        defenses = {
            'T1190': [
                'Implement WAF (Web Application Firewall)',
                'Regular vulnerability scanning',
                'Input validation and sanitization',
                'Keep software updated'
            ],
            'T1059': [
                'Restrict command execution permissions',
                'Implement application whitelisting',
                'Monitor command line activity',
                'Use endpoint detection and response (EDR)'
            ],
            'T1021': [
                'Network segmentation',
                'Monitor for unusual RDP/SSH connections',
                'Implement multi-factor authentication',
                'Regular review of service accounts'
            ],
            'T1048': [
                'Monitor outbound network traffic',
                'Implement data loss prevention (DLP)',
                'Encrypt sensitive data',
                'Network traffic analysis'
            ]
        }
        
        return defenses.get(technique_id, [
            'Monitor for suspicious activity',
            'Review security logs regularly',
            'Keep systems updated'
        ])
    
    def _compute_chain_threat(self, chains: List[Dict]) -> float:
        """
        Compute overall threat level from detected chains
        """
        if not chains:
            return 0.1
        
        # Calculate based on chain confidence and severity
        threat_scores = []
        
        for chain in chains:
            # Base score from confidence
            base_score = chain.get('confidence', 0.5)
            
            # Adjust based on chain length
            length_factor = min(1.0, chain.get('length', 1) / 10.0)
            
            # Adjust based on techniques used
            technique_factor = self._get_technique_severity(chain.get('techniques', []))
            
            # Combined score
            chain_score = base_score * 0.4 + length_factor * 0.3 + technique_factor * 0.3
            threat_scores.append(chain_score)
        
        return min(1.0, np.mean(threat_scores))
    
    def _get_technique_severity(self, techniques: List[str]) -> float:
        """
        Get severity score for list of techniques
        """
        if not techniques:
            return 0.5
        
        # Define technique severities
        severities = {
            'T1190': 0.8,  # Initial access
            'T1059': 0.7,  # Execution
            'T1068': 0.9,  # Privilege escalation
            'T1021': 0.8,  # Lateral movement
            'T1048': 0.9,  # Exfiltration
            'T1070': 0.6   # Defense evasion
        }
        
        # Average severity of techniques
        tech_scores = [severities.get(tech, 0.5) for tech in techniques]
        return np.mean(tech_scores) if tech_scores else 0.5
    
    def _compute_chain_confidence(self, chains: List[Dict]) -> float:
        """
        Compute overall confidence in chain detection
        """
        if not chains:
            return 0.1
        
        confidences = [chain.get('confidence', 0.5) for chain in chains]
        return np.mean(confidences)
    
    def _get_recommended_action(self, chains: List[Dict], predictions: List[Dict]) -> str:
        """
        Get recommended action based on detected chains
        """
        if not chains:
            return "MONITOR - No attack chains detected"
        
        # Check for high-confidence chains
        high_conf_chains = [c for c in chains if c.get('confidence', 0) > 0.8]
        
        if high_conf_chains:
            # Check for critical techniques
            critical_techs = ['T1048', 'T1068', 'T1190']  # Exfiltration, privilege escalation, initial access
            
            for chain in high_conf_chains:
                if any(tech in critical_techs for tech in chain.get('techniques', [])):
                    return "BLOCK - Critical attack chain detected"
            
            return "ISOLATE - High-confidence attack chain, isolate affected systems"
        
        # Check for predictions
        if predictions:
            high_conf_predictions = [p for p in predictions if p.get('confidence', 0) > 0.7]
            if high_conf_predictions:
                return "PREVENT - Implement defenses against predicted next steps"
        
        return "INVESTIGATE - Potential attack chain detected, needs investigation"
    
    def _error_response(self, error_message: str) -> Dict[str, Any]:
        """
        Generate error response
        """
        return {
            'agent_id': self.agent_id,
            'agent_name': self.name,
            'error': error_message,
            'chains_detected': [],
            'campaigns': [],
            'prediction': None,
            'reasoning_state': self.get_reasoning_state(),
            'decision': {
                'threat_level': 0.5,
                'confidence': 0.1,
                'evidence': [{'type': 'AGENT_ERROR', 'description': error_message}]
            }
        }
    
    def get_campaign_report(self, campaign_id: str) -> Optional[Dict[str, Any]]:
        """
        Get detailed report for a campaign
        """
        if campaign_id not in self.campaigns:
            return None
        
        campaign = self.campaigns[campaign_id]
        
        # Calculate campaign metrics
        duration = self._calculate_campaign_duration(campaign)
        impact_score = self._calculate_impact_score(campaign)
        
        # Generate timeline
        timeline = self._generate_campaign_timeline(campaign)
        
        # Generate recommendations
        recommendations = self._generate_campaign_recommendations(campaign)
        
        report = {
            'campaign_id': campaign_id,
            'summary': {
                'start_time': campaign['start_time'],
                'last_seen': campaign['last_seen'],
                'duration_hours': duration,
                'source_ips': list(campaign['source_ips']),
                'targets': list(campaign['targets']),
                'event_count': campaign['event_count'],
                'unique_techniques': len(campaign['techniques']),
                'chains_detected': len(campaign['chains']),
                'impact_score': impact_score
            },
            'techniques_used': [
                {'id': tech_id, 'name': self.mitre_techniques.get(tech_id, {}).get('name', 'Unknown')}
                for tech_id in campaign['techniques']
            ],
            'detected_chains': campaign['chains'][:5],  # Top 5 chains
            'timeline': timeline,
            'recommendations': recommendations,
            'status': 'ACTIVE' if self._is_campaign_active(campaign) else 'INACTIVE'
        }
        
        return report
    
    def _calculate_campaign_duration(self, campaign: Dict) -> float:
        """
        Calculate campaign duration in hours
        """
        try:
            start = datetime.fromisoformat(campaign['start_time'].replace('Z', '+00:00'))
            end = datetime.fromisoformat(campaign['last_seen'].replace('Z', '+00:00'))
            duration = (end - start).total_seconds() / 3600
            return round(duration, 2)
        except:
            return 0.0
    
    def _calculate_impact_score(self, campaign: Dict) -> float:
        """
        Calculate impact score for campaign (0-1)
        """
        score = 0.0
        
        # Factor 1: Number of source IPs
        ip_factor = min(1.0, len(campaign['source_ips']) / 10.0)
        score += ip_factor * 0.2
        
        # Factor 2: Number of targets
        target_factor = min(1.0, len(campaign['targets']) / 5.0)
        score += target_factor * 0.3
        
        # Factor 3: Techniques used
        tech_severity = self._get_technique_severity(list(campaign['techniques']))
        score += tech_severity * 0.4
        
        # Factor 4: Event count
        event_factor = min(1.0, campaign['event_count'] / 50.0)
        score += event_factor * 0.1
        
        return min(1.0, score)
    
    def _generate_campaign_timeline(self, campaign: Dict) -> List[Dict]:
        """
        Generate timeline of campaign events
        """
        timeline = []
        
        # Extract events from chains
        for chain in campaign['chains'][:10]:  # Limit to 10 chains
            for event in chain.get('events', []):
                timeline.append({
                    'timestamp': event['timestamp'],
                    'technique': event['technique'],
                    'description': event['description'],
                    'severity': event.get('severity', 'medium'),
                    'chain': chain.get('pattern_name', 'unknown')
                })
        
        # Sort by timestamp
        timeline.sort(key=lambda x: x['timestamp'])
        
        return timeline[:20]  # Limit to 20 events
    
    def _generate_campaign_recommendations(self, campaign: Dict) -> List[str]:
        """
        Generate recommendations for dealing with campaign
        """
        recommendations = []
        
        # Based on techniques used
        for tech_id in campaign['techniques']:
            defenses = self._get_defense_for_technique(tech_id)
            recommendations.extend(defenses[:2])  # Top 2 defenses per technique
        
        # General recommendations
        if len(campaign['source_ips']) > 1:
            recommendations.append("Block all source IPs associated with campaign")
        
        if len(campaign['targets']) > 1:
            recommendations.append("Isolate and investigate all affected targets")
        
        # Remove duplicates
        unique_recommendations = []
        seen = set()
        for rec in recommendations:
            if rec not in seen:
                seen.add(rec)
                unique_recommendations.append(rec)
        
        return unique_recommendations[:5]  # Top 5 recommendations
    
    def _is_campaign_active(self, campaign: Dict) -> bool:
        """
        Check if campaign is still active
        """
        try:
            last_seen = datetime.fromisoformat(campaign['last_seen'].replace('Z', '+00:00'))
            time_since_last = (datetime.now() - last_seen).total_seconds()
            
            # Consider active if seen in last 24 hours
            return time_since_last < 86400
        except:
            return False
    
    def get_agent_status(self) -> Dict[str, Any]:
        """
        Get comprehensive agent status
        """
        return {
            'agent_id': self.agent_id,
            'name': self.name,
            'status': 'ACTIVE',
            'confidence': self.confidence,
            'metrics': self.metrics,
            'campaigns': {
                'active': len([c for c in self.campaigns.values() if self._is_campaign_active(c)]),
                'total': len(self.campaigns),
                'avg_events_per_campaign': np.mean([c['event_count'] for c in self.campaigns.values()]) 
                if self.campaigns else 0
            },
            'detection_capabilities': {
                'mitre_techniques': len(self.mitre_techniques),
                'attack_patterns': sum(len(patterns) for patterns in self.attack_patterns.values()),
                'avg_chain_length': self.metrics['avg_chain_length'],
                'correlation_window_hours': self.correlation_window / 3600
            },
            'config': {
                'thresholds': self.thresholds,
                'max_sequence_length': self.max_sequence_length,
                'min_chain_length': self.thresholds['min_chain_length']
            }
        }